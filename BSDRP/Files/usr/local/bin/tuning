#!/bin/sh
#
# FreeBSD network tuning tool
# https://bsdrp.net
#
# Copyright (c) 2017-2018, The BSDRP Development Team
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#

# Strict script
set -eu

### Global variables
HOST=false
ROUTER=false
VM=false
VERSION=""
VERBOSE=false
LOADERCFG=/tmp/loader.conf
SYSCTLCFG=/tmp/sysctl.conf
RCCONF=/tmp/rc.conf
IF_LIST=""
NCORE=0

### Functions
# name
# chk_ : check if
# add_ : add line to file

# A usefull function (from: http://code.google.com/p/sh-die/)
die() { echo -n "EXIT: " >&2; echo "$@" >&2; exit 1; }

usage () {
	# Display usage
	echo "Usage: $0 [-v]"
	echo " -v: verbose mode"
	exit 0
}

add () {
	# Add $1 into file $2
	# Prevent to do it twice
	grep -q "$1" $2 && return 0
	echo "$1" >> $2
	if (${VERBOSE}); then
		echo "File: $2"
		echo "$1"
	fi
	return 0
}

add_loader () {
	# Add $1 into LOADERCFG file
	add "$1" ${LOADERCFG}
	return 0
}

add_sysctl () {
	add "$1" ${SYSCTLCFG}
	return 0
}

add_rc () {
	# Add $1 into ${RCCONF} file
	add "$1" ${RCCONF}
	return 0
}

update_rc () {
	sysrc -f ${RCCONF} $1
	#ifconfigcloned_interfaces+=" gif0"
}

chk_sysctl_lt () {
	# Check the sysctl parameter is at least configured to the value
	# $1: sysctl parameter
	# $2: recommended value
	# return 0 if yes, 1 if not
	[ `sysctl -nq $1` -lt $2 ] && return 0 || return 1
}

chk_sysctl_eq () {
	# Check the sysctl parameter match (equal) the value
	# $1: sysctl parameter
	# $2: value
	# return 0 if yes, 1 if not
	[ `sysctl -nq $1` -eq $2 ] && return 0 || return 1
}

chk_if_cap () {
	# Check if the interface have capabilities and if it's enabled return true (0)
	# $1: interface
	# $2: capability
	ifconfig -m $1 | egrep -q "capabilities.*$2" && return 0 || return 1
}

chk_if_cap_enabled () {
	# Check if the interface capability is enabled
	# $1: if
	# $2: capability
	# return 0 if enabled, 1 is not
	ifconfig -m $1 | egrep -q "options.*$2" && return 0 || return 1
}

tune_cpu_ht () {
	# Check if HyperThreading is disabled (router only)
	if sysctl kern.sched.topology_spec | grep -q THREAD; then
		add_loader "# HyperThreading impact badly forwarding performance: Disable it"
		add_loader "machdep.hyperthreading_allowed=\"0\""
	fi
	return 0
}

tune_harvest () {
	# Tune the harvest mask (router only)
	if ! chk_sysctl_eq kern.random.harvest.mask 351; then
		add_rc "# Disable INTERRUPT and ETHERNET from for entropy sources"
		add_rc "harvest_mask=\"351\""
	fi
	return 0
}

tune_if_tsolro () {
	# Disable TSO/LRO (router only)
	# $1: list of interfaces to check
	if chk_sysctl_eq net.inet.tcp.tso 0; then
		add_sysctl "# A router/firewall Should not use TSO"
		add_sysctl "net.inet.tcp.tso=0"
	fi
	# Check if TSO or LRO are enabled on each interfaces
	# For each ethernet interfaces
	for i in $1; do
		for CAP in LRO TSO4 TSO6; do
			if chk_if_cap_enabled $i ${CAP}; then
				add_rc "# Disable TSO/LRO on interface $i"
				add_rc "ifconfig_$i=\"-tso4 -tso6 -lro -vlanhwtso\""
			fi
		done
	done
	return 0
}

tune_modules () {
	# Check if usefull modules are loaded
	if grep -q 'Feature.*AESNI' /var/run/dmesg.boot ; then
		# CPU support it, check if not already loaded
		if ! kldstat -n aesni 2>&1 | grep -q aesni; then
			add_rc "# CPU has AESNI feature, load the module"
			add_rc "kld_list=\"cryptodev aesni\""
		fi
	fi
}

get_ncores () {
	# Get number of cores (excluding threads if enabled)
	# Didn't found how to get number of physical core if HT is enabled using only sysctl
	# Need to deal with /var/run/dmesg (dirty)
	SMP=$(grep -e '^FreeBSD/SMP.*x' /var/run/dmesg.boot)
	if echo ${SMP} | grep -q threads; then
		PACKAGE=""
		PACKAGE=$(echo ${SMP} | cut -d ' ' -f 2)
		CORE=""
		CORE=$(echo ${SMP} | cut -d ' ' -f 5)
		[ -z "${PACKAGE}" ] && die "BUG in get_ncores regarding extracting PACKAGE number"
		[ -z "${CORE}" ] && die "BUG in get_ncores regarding extracting CORE number"
		echo $(( PACKAGE * CORE ))
	else
		# No Hyper threading, easy:
		sysctl -n hw.ncpu
	fi
}

get_if_eth () {
	# Return list of Ethernet only interfaces, by excluding bridge, tag, lagg, vlan, wlan, etc.
	# TOÂ DO: complete this list
	for i in $(ifconfig -l "ether"); do
		ifconfig $i | grep -q groups || echo $i
	done
}

tune_if_em () {
	# Intel Gigabit
	if ! chk_sysctl_eq hw.em.rx_process_limit -1; then
		add_boot "# Remove limiting number of maximum packets to proceed"
		add_boot "hw.em.rx_process_limit=\"-1\""
	fi
	if ! chk_sysctl_eq hw.igb.rx_process_limit -1; then
		add_boot "# Remove limiting number of maximum packets to proceed"
		add_boot "hw.igb.rx_process_limit=\"-1\""
	fi
	return 0
}

tune_if_ixgbe () {
	# intel 10G
	# RX queue = CORE
	if ! chk_sysctl_eq hw.em.rx_process_limit -1; then
		add_boot "# Remove limiting number of maximum packets to proceed"
		add_boot "hw.em.rx_process_limit=\"-1\""
	fi
	# Increase number of rx queue if core>8, but keept power of 2
	if [ ${NCORE} -ge 16 ]; then
		RXQ=""
		RXQ=$(sysctl dev.ixgbe.0 | grep txq_pidx | wc -l)
		sysctl hw.ix.num_queue
		[ -z "${RXQ}" ] && die "BUG in tune_if_ixgbe() to extract RXQ"
		if [ ${RXQ} -lt 16 ]; then
			add_boot "# ixgbe(4) create 8 RX queues per default, increase this to 16"
			add_boot  "hw.ixgbe.blabla.rx.queue=\"16\""
		fi
	fi
	# Allow unsupported SFP
	# hw.ix.unsupported_sfp="1"
	# hw.ix.allow_unsupported_sfp="1"
}

tune_if_cxgbe () {
	# Chelsio 10G
	# Global Chelsio parameters
	for i in toe rdma iscsi fcoe; do
		chk_sysctl_eq hw.cxgbe.${i}caps_allowed 0 || \
			add_boot "hw.cxgbe.${i}caps_allowed=\"0\""
	done
	# Increase number of rx queue if core>8, but keept power of 2
	if [ ${NCORE} -ge 16 ]; then
		for i in $(seq 0 $(( $(sysctl dev.cxl. | grep nrxq | wc -l) - 1 )) ); do
			RXQ=$(sysctl dev.cxl.$i.nrxq)
			[ -z "${RXQ}" ] && die "BUG in tune_if_cxgbe() to extract RXQ"
			if [ ${RXQ} -lt 16 ]; then
				add_boot "# cxgbe(4) create 8 RX queues per default, increase this to 16"
				add_boot  "dev.cxl.$i.nrxq=\"16\""
			fi
		done
	fi
}

tune_if () {
	# NIC drivers tuning
	IF_LIST=$(get_if_eth)
	($ROUTER) && tune_if_tsolro "${IF_LIST}"
	# Need to found another way than interface name
	# because interface can be renamed
	sysctl -nq dev.em.0.rx_processing_limit > /dev/null 2>&1 && tune_if_em || true
	sysctl -nq dev.igb.0.rx_processing_limit > /dev/null 2>&1 && tune_if_em || true
	sysctl -nq dev.ix.0.rx_processing_limit > /dev/null 2>&1 && tune_if_ixgbe || true
	sysctl -nq dev.cxl.0.nrxq > /dev/null 2>&1 && tune_if_cxgbe || true
}

net_netstat () {
	# Analysing netstat -m output and provide advice regarding the result
	echo "TODO: netstat"
}

net_inet () {
	# http://wiki.freebsd.org/NetworkPerformanceTuning
	# default value of send interface queue length
	# This value should be equal to the total of all interfaces's txd belonging to a lagg
	# ixgbe uses a default txd of 2048, then let's suppose 4 ixgbe in a lagg: 8192
	if chk_sysctl_lt net.link.ifqmaxlen 8192; then
		add_sysctl "# Increasing the default ifqmaxlen, in case of lagg usage"
		add_sysctl "net.link.ifqmaxlen=\"8192\""
	fi
	for VALUE in net.inet.raw.maxdgram net.inet.raw.recvspace; do
        if ! chk_sysctl_lt ${VALUE} 16384; then
			add_sysctl "# Increase max datagram size"
			add_sysctl "${VALUE}=\"16384\""
		fi
    done
	if ! chk_sysctl_eq et.inet.ip.redirect 0; then
		add_sysctl "# Disable generating ICMP redirect"
		add_sysctl "net.inet.ip.redirect=\"0\""
	fi
}

net_netisr () {
	# http://wiki.freebsd.org/NetworkPerformanceTuning
	chk_sysctl_lt net.route.netisr_maxqlen 2048
}

net_mbuf () {
	# kern.ipc.nmbclusters must be increased if multiple igb (man igb)
	# Need to calculate (regarding RAM size) this value
	# Does vm.kmem_size should be upgraded too ?
	# igb loads 8 rings, each of 1024 per NIC
	chk_sysctl_lt kern.ipc.nmbclusters 262144
	echo "On the following output, with all your NIC already configured"
	echo "  check the current and total"
	netstat -m | grep "mbuf clusters in use"
}

timecounter () {
	# Are the timecounter tuning usefull ?
	TIMECOUTER_CHOICE=`sysctl -n sysctl kern.timecounter.choice`
	if echo "${TIMECOUTER_CHOICE}" | grep -q "HPET"	; then
		sysctl -n kern.timecounter.hardware | grep -q HPET || \
			echo "sysctl kern.timecounter.hardware=HPET"
	fi
}
###################
## Main function ##
###################

args=$(getopt hv $*)
set -- $args
for i; do
	case "$i" in
	-h)
		usage
		shift
		;;
	-v)
		VERBOSE=true
		shift
		;;
	--)
		shift
		break
	esac
done

# Cleanup previous files
for f in ${LOADERCFG} ${SYSCTLCFG} ${RCCONF}; do
	echo "# BSD Router Project tuning script result" > $f
done

# Look for VM environnement
sysctl -n kern.vm_guest | grep -q -v "none" && VM=true || VM=false
# Check if is router/firewall mode
chk_sysctl_eq net.inet.ip.forwarding 1 && ROUTER=true

NCORE=$(get_ncores)

tune_if
net_inet
($ROUTER) && tune_cpu_ht
($ROUTER) && tune_harvest
tune_modules

exit 0
net_netisr
echo "#<== End of /boot/loader.conf.local"
net_netstat
echo "#==> To be added to /etc/rc.conf"
for NIC in `ifconfig -l "ether"`; do
	#skip loopback interfaces
       echo $NIC | egrep -q "lo[[:digit:]]" && continue
	# Check only interface with vlan configured on them
	if egrep -q "ifconfig_vlan.*${NIC}" /etc/rc.conf; then
		if chk_if_cap ${NIC} VLAN_HWFILTER; then
			if ! chk_if_cap_enabled ${NIC} VLAN_HWFILTER; then
				echo "${NIC} configured with vlan and support VLAN_HWFILTER"
				echo " => add the vlanhwfilter option to ifconfig_${NIC} in /etc/rc.conf"
			fi
		fi # chk_if_cap
	fi # rc.conf
	# Check for virtualized
	if (${VM}); then
		if chk_if_cap ${NIC} POLLING; then
			if ! chk_if_cap_enabled ${NIC} POLLING; then
				# http://lists.freebsd.org/pipermail/freebsd-net/2013-May/035626.html
				echo "In VM, ${NIC} can have better behavior if POLLING was enabled"
				echo " => Enable polling in /etc/rc.conf.misc"
			fi
		fi
		# need disable hardware assisted features (need to found reference about this tip)
		for CAP in RXCSUM TXCSUM TSO4 TSO6; do
           	chk_if_cap_enabled ${NIC} ${CAP} && \
					echo "${NIC} have ${CAP} enabled: Disable it in a VM"
       	done # end for CAP
	fi
done

echo "Done!"
