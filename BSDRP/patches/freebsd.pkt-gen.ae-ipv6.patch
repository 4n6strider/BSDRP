Index: tools/tools/netmap/ctrs.h
===================================================================
--- tools/tools/netmap/ctrs.h	(nonexistent)
+++ tools/tools/netmap/ctrs.h	(working copy)
@@ -0,0 +1,114 @@
+#ifndef CTRS_H_
+#define CTRS_H_
+
+/* $FreeBSD$ */
+
+#include <sys/time.h>
+
+/* counters to accumulate statistics */
+struct my_ctrs {
+	uint64_t pkts, bytes, events, drop;
+	uint64_t min_space;
+	struct timeval t;
+};
+
+/* very crude code to print a number in normalized form.
+ * Caller has to make sure that the buffer is large enough.
+ */
+static const char *
+norm2(char *buf, double val, char *fmt, int normalize)
+{
+	char *units[] = { "", "K", "M", "G", "T" };
+	u_int i;
+	if (normalize)
+		for (i = 0; val >=1000 && i < sizeof(units)/sizeof(char *) - 1; i++)
+			val /= 1000;
+	else
+		i=0;
+	sprintf(buf, fmt, val, units[i]);
+	return buf;
+}
+
+static __inline const char *
+norm(char *buf, double val, int normalize)
+{
+	
+	if (normalize)
+		return norm2(buf, val, "%.3f %s", normalize);
+	else
+		return norm2(buf, val, "%.0f %s", normalize);
+}
+
+static __inline int
+timespec_ge(const struct timespec *a, const struct timespec *b)
+{
+
+	if (a->tv_sec > b->tv_sec)
+		return (1);
+	if (a->tv_sec < b->tv_sec)
+		return (0);
+	if (a->tv_nsec >= b->tv_nsec)
+		return (1);
+	return (0);
+}
+
+static __inline struct timespec
+timeval2spec(const struct timeval *a)
+{
+	struct timespec ts = {
+		.tv_sec = a->tv_sec,
+		.tv_nsec = a->tv_usec * 1000
+	};
+	return ts;
+}
+
+static __inline struct timeval
+timespec2val(const struct timespec *a)
+{
+	struct timeval tv = {
+		.tv_sec = a->tv_sec,
+		.tv_usec = a->tv_nsec / 1000
+	};
+	return tv;
+}
+
+
+static __inline struct timespec
+timespec_add(struct timespec a, struct timespec b)
+{
+	struct timespec ret = { a.tv_sec + b.tv_sec, a.tv_nsec + b.tv_nsec };
+	if (ret.tv_nsec >= 1000000000) {
+		ret.tv_sec++;
+		ret.tv_nsec -= 1000000000;
+	}
+	return ret;
+}
+
+static __inline struct timespec
+timespec_sub(struct timespec a, struct timespec b)
+{
+	struct timespec ret = { a.tv_sec - b.tv_sec, a.tv_nsec - b.tv_nsec };
+	if (ret.tv_nsec < 0) {
+		ret.tv_sec--;
+		ret.tv_nsec += 1000000000;
+	}
+	return ret;
+}
+
+static uint64_t
+wait_for_next_report(struct timeval *prev, struct timeval *cur,
+		int report_interval)
+{
+	struct timeval delta;
+
+	delta.tv_sec = report_interval/1000;
+	delta.tv_usec = (report_interval%1000)*1000;
+	if (select(0, NULL, NULL, NULL, &delta) < 0 && errno != EINTR) {
+		perror("select");
+		abort();
+	}
+	gettimeofday(cur, NULL);
+	timersub(cur, prev, &delta);
+	return delta.tv_sec* 1000000 + delta.tv_usec;
+}
+#endif /* CTRS_H_ */

Property changes on: tools/tools/netmap/ctrs.h
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Added: svn:keywords
## -0,0 +1 ##
+FreeBSD=%H
\ No newline at end of property
Added: svn:mime-type
## -0,0 +1 ##
+text/plain
\ No newline at end of property
Index: tools/tools/netmap/pkt-gen.c
===================================================================
--- tools/tools/netmap/pkt-gen.c	(revision 309478)
+++ tools/tools/netmap/pkt-gen.c	(working copy)
@@ -1,6 +1,6 @@
 /*
  * Copyright (C) 2011-2014 Matteo Landi, Luigi Rizzo. All rights reserved.
- * Copyright (C) 2013-2014 Universita` di Pisa. All rights reserved.
+ * Copyright (C) 2013-2015 Universita` di Pisa. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -37,8 +37,6 @@
  *
  */
 
-// #define TRASH_VHOST_HDR
-
 #define _GNU_SOURCE	/* for CPU_SET() */
 #include <stdio.h>
 #define NETMAP_WITH_LIBS
@@ -49,12 +47,17 @@
 #include <unistd.h>	// sysconf()
 #include <sys/poll.h>
 #include <arpa/inet.h>	/* ntohs */
+#ifndef _WIN32
 #include <sys/sysctl.h>	/* sysctl */
+#endif
 #include <ifaddrs.h>	/* getifaddrs */
 #include <net/ethernet.h>
 #include <netinet/in.h>
 #include <netinet/ip.h>
+#include <netinet/ip6.h>
 #include <netinet/udp.h>
+#include <assert.h>
+#include <math.h>
 
 #include <pthread.h>
 
@@ -62,6 +65,71 @@
 #include <pcap/pcap.h>
 #endif
 
+#include "ctrs.h"
+
+static void usage(void);
+
+#ifdef _WIN32
+#define cpuset_t        DWORD_PTR   //uint64_t
+static inline void CPU_ZERO(cpuset_t *p)
+{
+        *p = 0;
+}
+
+static inline void CPU_SET(uint32_t i, cpuset_t *p)
+{
+        *p |= 1<< (i & 0x3f);
+}
+
+#define pthread_setaffinity_np(a, b, c) !SetThreadAffinityMask(a, *c)    //((void)a, 0)
+#define TAP_CLONEDEV	"/dev/tap"
+#define AF_LINK	18	//defined in winsocks.h
+#define CLOCK_REALTIME_PRECISE CLOCK_REALTIME
+#include <net/if_dl.h>
+
+/*
+ * Convert an ASCII representation of an ethernet address to
+ * binary form.
+ */
+struct ether_addr *
+ether_aton(const char *a)
+{
+	int i;
+	static struct ether_addr o;
+	unsigned int o0, o1, o2, o3, o4, o5;
+
+	i = sscanf(a, "%x:%x:%x:%x:%x:%x", &o0, &o1, &o2, &o3, &o4, &o5);
+
+	if (i != 6)
+		return (NULL);
+
+	o.octet[0]=o0;
+	o.octet[1]=o1;
+	o.octet[2]=o2;
+	o.octet[3]=o3;
+	o.octet[4]=o4;
+	o.octet[5]=o5;
+
+	return ((struct ether_addr *)&o);
+}
+
+/*
+ * Convert a binary representation of an ethernet address to
+ * an ASCII string.
+ */
+char *
+ether_ntoa(const struct ether_addr *n)
+{
+	int i;
+	static char a[18];
+
+	i = sprintf(a, "%02x:%02x:%02x:%02x:%02x:%02x",
+	    n->octet[0], n->octet[1], n->octet[2],
+	    n->octet[3], n->octet[4], n->octet[5]);
+	return (i < 17 ? NULL : (char *)&a);
+}
+#endif /* _WIN32 */
+
 #ifdef linux
 
 #define cpuset_t        cpu_set_t
@@ -114,6 +182,7 @@
 	"http://info.iet.unipi.it/~luigi/netmap/ ";
 
 int verbose = 0;
+int normalize = 1;
 
 #define SKIP_PAYLOAD 1 /* do not check payload. XXX unused */
 
@@ -128,16 +197,35 @@
 #define MAX_BODYSIZE	16384
 
 struct pkt {
-	struct virt_header vh;
 	struct ether_header eh;
-	struct ip ip;
-	struct udphdr udp;
-	uint8_t body[MAX_BODYSIZE];	// XXX hardwired
+	union {
+		struct {
+			struct ip ip;
+			struct udphdr udp;
+			uint8_t body[MAX_BODYSIZE]; // XXX hardwired
+		} ipv4;
+		struct {
+			struct ip6_hdr ip;
+			struct udphdr udp;
+			uint8_t body[MAX_BODYSIZE]; // XXX hardwired
+		} ipv6;
+	};	
 } __attribute__((__packed__));
 
+#define    PKT(p, f, af)   \
+	((af) == AF_INET ? (p)->ipv4.f: (p)->ipv6.f)
+
 struct ip_range {
 	char *name;
-	uint32_t start, end; /* same as struct in_addr */
+	union {
+		struct {
+			uint32_t start, end; /* same as struct in_addr */
+		} ipv4;
+		struct {
+			struct in6_addr start, end;
+			uint8_t sgroup, egroup;
+		} ipv6;
+	};
 	uint16_t port0, port1;
 };
 
@@ -162,6 +250,7 @@
  */
 
 struct glob_arg {
+	int af;     /* address family AF_INET/AF_INET6 */
 	struct ip_range src_ip;
 	struct ip_range dst_ip;
 	struct mac_range dst_mac;
@@ -169,10 +258,13 @@
 	int pkt_size;
 	int burst;
 	int forever;
-	int npackets;	/* total packets to send */
+	uint64_t npackets;	/* total packets to send */
 	int frags;	/* fragments per packet */
 	int nthreads;
-	int cpus;
+	int cpus;	/* cpus used for running */
+	int system_cpus;	/* cpus on the system */
+	int softchecksum;	/* Software UDP checksum calculation */
+
 	int options;	/* testing */
 #define OPT_PREFETCH	1
 #define OPT_ACCESS	2
@@ -181,10 +273,10 @@
 #define OPT_TS		16	/* add a timestamp */
 #define OPT_INDIRECT	32	/* use indirect buffers, tx only */
 #define OPT_DUMP	64	/* dump rx/tx traffic */
-#define OPT_MONITOR_TX  128
-#define OPT_MONITOR_RX  256
+#define OPT_RUBBISH	256	/* send wathever the buffers contain */
 #define OPT_RANDOM_SRC  512
 #define OPT_RANDOM_DST  1024
+#define OPT_PPS_STATS   2048
 	int dev_type;
 #ifndef NO_PCAP
 	pcap_t *p;
@@ -198,6 +290,7 @@
 	struct nm_desc *nmd;
 	int report_interval;		/* milliseconds between prints */
 	void *(*td_body)(void *);
+	int td_type;
 	void *mmap_addr;
 	char ifname[MAX_IFNAMELEN];
 	char *nmr_config;
@@ -204,7 +297,11 @@
 	int dummy_send;
 	int virt_header;	/* send also the virt_header */
 	int extra_bufs;		/* goes in nr_arg3 */
+	int extra_pipes;	/* goes in nr_arg1 */
 	char *packet_file;	/* -P option */
+#define	STATS_WIN	15
+	int win_idx;
+	int64_t win[STATS_WIN];
 };
 enum dev_type { DEV_NONE, DEV_NETMAP, DEV_PCAP, DEV_TAP };
 
@@ -220,7 +317,11 @@
 	int cancel;
 	int fd;
 	struct nm_desc *nmd;
-	volatile uint64_t count;
+	/* these ought to be volatile, but they are
+	 * only sampled and errors should not accumulate
+	 */
+	struct my_ctrs ctr;
+
 	struct timespec tic, toc;
 	int me;
 	pthread_t thread;
@@ -230,68 +331,146 @@
 	void *frame;
 };
 
+static __inline uint16_t
+cksum_add(uint16_t sum, uint16_t a)
+{
+	uint16_t res;
 
+	res = sum + a;
+	return (res + (res < a));
+}
+
+static void
+extract_ipv4_addr(char *name, uint32_t *addr, uint16_t *port)
+{
+	struct in_addr a;
+	char *pp;
+
+	pp = strchr(name, ':');
+	if (pp != NULL) {   /* do we have ports ? */
+		*pp++ = '\0';
+		*port = (uint16_t)strtol(pp, NULL, 0);
+	}
+
+	inet_pton(AF_INET, name, &a);
+	*addr = ntohl(a.s_addr);
+}
+
+static void
+extract_ipv6_addr(char *name, struct in6_addr *addr, uint16_t *port,
+	uint8_t *group)
+{
+	char *pp;
+
+	/*
+	 * We accept IPv6 address in the following form:
+	 *  group@[2001:DB8::1001]:port (w/ brackets and port)
+	 *  group@[2001:DB8::1]     (w/ brackets and w/o port)
+	 *  group@2001:DB8::1234    (w/o brackets and w/o port)
+	 */
+	pp = strchr(name, '@');
+	if (pp != NULL) {
+		*pp++ = '\0';
+		*group = (uint8_t)strtol(name, NULL, 0);
+		if (*group > 7)
+			*group = 7;
+		name = pp;
+	}
+	if (name[0] == '[')
+		name++;
+	pp = strchr(name, ']');
+	if (pp != NULL)	
+		*pp++ = '\0';
+	if (pp != NULL && *pp != ':')
+		pp = NULL;
+	if (pp != NULL) {   /* do we have ports ? */
+		*pp++ = '\0';
+		*port = (uint16_t)strtol(pp, NULL, 0);
+	}
+	inet_pton(AF_INET6, name, addr);
+}		
+
 /*
  * extract the extremes from a range of ipv4 addresses.
  * addr_lo[-addr_hi][:port_lo[-port_hi]]
  */
-static void
-extract_ip_range(struct ip_range *r)
+static int
+extract_ip_range(struct ip_range *r, int af)
 {
-	char *ap, *pp;
+	char *name, *ap, start[INET6_ADDRSTRLEN];
+	char end[INET6_ADDRSTRLEN];
 	struct in_addr a;
+	uint32_t tmp;
 
 	if (verbose)
 		D("extract IP range from %s", r->name);
-	r->port0 = r->port1 = 0;
-	r->start = r->end = 0;
 
+	name = strdup(r->name);
+	if (name == NULL) {
+		D("strdup failed");
+		usage();
+	}
 	/* the first - splits start/end of range */
-	ap = index(r->name, '-');	/* do we have ports ? */
-	if (ap) {
+	ap = strchr(name, '-');
+	if (ap != NULL)
 		*ap++ = '\0';
-	}
-	/* grab the initial values (mandatory) */
-	pp = index(r->name, ':');
-	if (pp) {
-		*pp++ = '\0';
-		r->port0 = r->port1 = strtol(pp, NULL, 0);
-	};
-	inet_aton(r->name, &a);
-	r->start = r->end = ntohl(a.s_addr);
-	if (ap) {
-		pp = index(ap, ':');
-		if (pp) {
-			*pp++ = '\0';
-			if (*pp)
-				r->port1 = strtol(pp, NULL, 0);
+	r->port0 = 1234;    /* default port */
+	if (af == AF_INET6) {
+		r->ipv6.sgroup = 7; /* default group */
+		extract_ipv6_addr(name, &r->ipv6.start, &r->port0,
+			&r->ipv6.sgroup);
+	} else
+		 extract_ipv4_addr(name, &r->ipv4.start, &r->port0);
+
+	r->port1 = r->port0;
+	if (af == AF_INET6) {
+		if (ap != NULL) {
+			r->ipv6.egroup = r->ipv6.sgroup;
+			extract_ipv6_addr(ap, &r->ipv6.end, &r->port1,
+				&r->ipv6.egroup);
+		} else {
+			r->ipv6.end = r->ipv6.start;
+			r->ipv6.egroup = r->ipv6.sgroup;
 		}
-		if (*ap) {
-			inet_aton(ap, &a);
-			r->end = ntohl(a.s_addr);
-		}
+	} else {
+		if (ap != NULL) {
+			extract_ipv4_addr(ap, &r->ipv4.end, &r->port1);
+			if (r->ipv4.start > r->ipv4.end) {
+				tmp = r->ipv4.end;
+				r->ipv4.end = r->ipv4.start;
+				r->ipv4.start = tmp;
+			}
+		} else
+			r->ipv4.end = r->ipv4.start;
 	}
+
 	if (r->port0 > r->port1) {
-		uint16_t tmp = r->port0;
+		tmp = r->port0;
 		r->port0 = r->port1;
 		r->port1 = tmp;
 	}
-	if (r->start > r->end) {
-		uint32_t tmp = r->start;
-		r->start = r->end;
-		r->end = tmp;
+	if (af == AF_INET) {
+		a.s_addr = htonl(r->ipv4.start);
+		inet_ntop(af, &a, start, sizeof(start));
+		a.s_addr = htonl(r->ipv4.end);
+		inet_ntop(af, &a, end, sizeof(end));
+	} else {
+		inet_ntop(af, &r->ipv6.start, start, sizeof(start));
+		inet_ntop(af, &r->ipv6.end, end, sizeof(end));
 	}
-	{
-		struct in_addr a;
-		char buf1[16]; // one ip address
+	if (af == AF_INET)
+		D("range is %s:%d to %s:%d", start, r->port0, end, r->port1);
+	else
+		D("range is %d@[%s]:%d to %d@[%s]:%d", r->ipv6.sgroup,
+			start, r->port0, r->ipv6.egroup, end, r->port1);
 
-		a.s_addr = htonl(r->end);
-		strncpy(buf1, inet_ntoa(a), sizeof(buf1));
-		a.s_addr = htonl(r->start);
-		if (1)
-		    D("range is %s:%d to %s:%d",
-			inet_ntoa(a), r->port0, buf1, r->port1);
-	}
+	free(name);
+	if (r->port0 != r->port1 ||
+		(af == AF_INET && r->ipv4.start != r->ipv4.end) ||
+		(af == AF_INET6 &&
+		!IN6_ARE_ADDR_EQUAL(&r->ipv6.start, &r->ipv6.end)))
+		return (OPT_COPY);
+	return (0);	
 }
 
 static void
@@ -327,11 +506,10 @@
 	int i;
 
 	(void)sig;	/* UNUSED */
-	D("received control-C on thread %p", pthread_self());
+	D("received control-C on thread %p", (void *)pthread_self());
 	for (i = 0; i < global_nthreads; i++) {
 		targs[i].cancel = 1;
 	}
-	signal(SIGINT, SIG_DFL);
 }
 
 /* sysctl wrapper to return the number of active CPUs */
@@ -345,6 +523,12 @@
 	sysctl(mib, 2, &ncpus, &len, NULL, 0);
 #elif defined(linux)
 	ncpus = sysconf(_SC_NPROCESSORS_ONLN);
+#elif defined(_WIN32)
+	{
+		SYSTEM_INFO sysinfo;
+		GetSystemInfo(&sysinfo);
+		ncpus = sysinfo.dwNumberOfProcessors;
+	}
 #else /* others */
 	ncpus = 1;
 #endif /* others */
@@ -482,7 +666,7 @@
 }
 
 /* Compute the checksum of the given ip header. */
-static uint16_t
+static uint32_t
 checksum(const void *data, uint16_t len, uint32_t sum)
 {
         const uint8_t *addr = data;
@@ -507,8 +691,8 @@
 	return sum;
 }
 
-static u_int16_t
-wrapsum(u_int32_t sum)
+static uint16_t
+wrapsum(uint32_t sum)
 {
 	sum = ~sum & 0xFFFF;
 	return (htons(sum));
@@ -518,10 +702,11 @@
  * Look for consecutive ascii representations of the size of the packet.
  */
 static void
-dump_payload(char *p, int len, struct netmap_ring *ring, int cur)
+dump_payload(const char *_p, int len, struct netmap_ring *ring, int cur)
 {
 	char buf[128];
 	int i, j, i0;
+	const unsigned char *p = (const unsigned char *)_p;
 
 	/* get the length in ASCII of the length of the packet. */
 
@@ -555,64 +740,193 @@
 #define uh_sum check
 #endif /* linux */
 
-/*
- * increment the addressed in the packet,
- * starting from the least significant field.
- *	DST_IP DST_PORT SRC_IP SRC_PORT
- */
 static void
-update_addresses(struct pkt *pkt, struct glob_arg *g)
+update_ip(struct pkt *pkt, struct glob_arg *g)
 {
-	uint32_t a;
-	uint16_t p;
-	struct ip *ip = &pkt->ip;
-	struct udphdr *udp = &pkt->udp;
+	struct ip *ip;
+	struct udphdr *udp;
+	uint32_t oaddr, naddr;
+	uint16_t oport, nport;
+	uint16_t ip_sum, udp_sum;
 
-    do {
-    	/* XXX for now it doesn't handle non-random src, random dst */
-	if (g->options & OPT_RANDOM_SRC) {
-		udp->uh_sport = random();
-		ip->ip_src.s_addr = random();
-	} else {
-		p = ntohs(udp->uh_sport);
-		if (p < g->src_ip.port1) { /* just inc, no wrap */
-			udp->uh_sport = htons(p + 1);
+	ip = &pkt->ipv4.ip;
+	udp = &pkt->ipv4.udp;
+	do {
+		ip_sum = udp_sum = 0;
+		naddr = oaddr = ntohl(ip->ip_src.s_addr);
+		nport = oport = ntohs(udp->uh_sport);
+		if (g->options & OPT_RANDOM_SRC) {
+			naddr = ip->ip_src.s_addr = random();
+			nport = udp->uh_sport = random();
 			break;
 		}
-		udp->uh_sport = htons(g->src_ip.port0);
+		if (oport < g->src_ip.port1) {
+			nport = oport + 1;
+			udp->uh_sport = htons(nport);
+			break;
+		}
+		nport = g->src_ip.port0;
+		udp->uh_sport = htons(nport);
+		if (oaddr < g->src_ip.ipv4.end) {
+			naddr = oaddr + 1;
+			ip->ip_src.s_addr = htonl(naddr);
+			break;
+		}
+		naddr = g->src_ip.ipv4.start;
+		ip->ip_src.s_addr = htonl(naddr);
 
-		a = ntohl(ip->ip_src.s_addr);
-		if (a < g->src_ip.end) { /* just inc, no wrap */
-			ip->ip_src.s_addr = htonl(a + 1);
+		/* update checksums if needed */
+		/* Some NIC drivers, like Intel,  disable hardware CRC checksum in */
+		/* netmap mode and don't allow to re-enable it. */
+		/* Chelsio drivers didn't have this limitation, but this calculation */
+		/* have a big performance. */
+		if (g->softchecksum) {
+			if (oaddr != naddr) {
+				ip_sum = cksum_add(ip_sum, ~oaddr >> 16);
+				ip_sum = cksum_add(ip_sum, ~oaddr & 0xffff);
+				ip_sum = cksum_add(ip_sum, naddr >> 16);
+				ip_sum = cksum_add(ip_sum, naddr & 0xffff);
+			}
+			if (oport != nport) {
+				udp_sum = cksum_add(udp_sum, ~oport);
+				udp_sum = cksum_add(udp_sum, nport);
+			}
+		}
+		naddr = oaddr = ntohl(ip->ip_dst.s_addr);
+		nport = oport = ntohs(udp->uh_dport);
+		if (g->options & OPT_RANDOM_DST) {
+			naddr = ip->ip_dst.s_addr = random();
+			nport = udp->uh_dport = random();
 			break;
 		}
-		ip->ip_src.s_addr = htonl(g->src_ip.start);
-
-		udp->uh_sport = htons(g->src_ip.port0);
+		if (oport < g->dst_ip.port1) {
+			nport = oport + 1;
+			udp->uh_dport = htons(nport);
+			break;
+		}
+		nport = g->dst_ip.port0;
+		udp->uh_dport = htons(nport);
+		if (oaddr < g->dst_ip.ipv4.end) {
+			naddr = oaddr + 1;
+			ip->ip_dst.s_addr = htonl(naddr);
+			break;
+		}
+		naddr = g->dst_ip.ipv4.start;
+		ip->ip_dst.s_addr = htonl(naddr);
+	} while (0);
+	/* update checksums */
+	if (g->softchecksum) {
+		if (oaddr != naddr) {
+			ip_sum = cksum_add(ip_sum, ~oaddr >> 16);
+			ip_sum = cksum_add(ip_sum, ~oaddr & 0xffff);
+			ip_sum = cksum_add(ip_sum, naddr >> 16);
+			ip_sum = cksum_add(ip_sum, naddr & 0xffff);
+		}
+		if (oport != nport) {
+			udp_sum = cksum_add(udp_sum, ~oport);
+			udp_sum = cksum_add(udp_sum, nport);
+		}
+		if (udp_sum != 0)
+			udp->uh_sum = cksum_add(udp->uh_sum, ~htons(udp_sum));
+		if (ip_sum != 0) {
+			ip->ip_sum = cksum_add(ip->ip_sum, ~htons(ip_sum));
+			udp->uh_sum = cksum_add(udp->uh_sum, ~htons(ip_sum));
+		}
 	}
+}
 
-	if (g->options & OPT_RANDOM_DST) {
-		udp->uh_dport = random();
-		ip->ip_dst.s_addr = random();
-	} else {
-		p = ntohs(udp->uh_dport);
-		if (p < g->dst_ip.port1) { /* just inc, no wrap */
-			udp->uh_dport = htons(p + 1);
+#ifndef s6_addr16
+#define    s6_addr16   __u6_addr.__u6_addr16
+#endif
+static void
+update_ip6(struct pkt *pkt, struct glob_arg *g)
+{
+	struct ip6_hdr *ip6;
+	struct udphdr *udp;
+	uint16_t udp_sum;
+	uint16_t oaddr, naddr;
+	uint16_t oport, nport;
+	uint8_t group;
+
+	ip6 = &pkt->ipv6.ip;
+	udp = &pkt->ipv6.udp;
+	do {
+		udp_sum = 0;
+		group = g->src_ip.ipv6.sgroup;
+		naddr = oaddr = ntohs(ip6->ip6_src.s6_addr16[group]);
+		nport = oport = ntohs(udp->uh_sport);
+		if (g->options & OPT_RANDOM_SRC) {
+			naddr = ip6->ip6_src.s6_addr16[group] = random();
+			nport = udp->uh_sport = random();
 			break;
 		}
-		udp->uh_dport = htons(g->dst_ip.port0);
+		if (oport < g->src_ip.port1) {
+			nport = oport + 1;
+			udp->uh_sport = htons(nport);
+			break;
+		}
+		nport = g->src_ip.port0;
+		udp->uh_sport = htons(nport);
+		if (oaddr < ntohs(g->src_ip.ipv6.end.s6_addr16[group])) {
+			naddr = oaddr + 1;
+			ip6->ip6_src.s6_addr16[group] = htons(naddr);
+			break;
+		}
+		naddr = ntohs(g->src_ip.ipv6.start.s6_addr16[group]);
+		ip6->ip6_src.s6_addr16[group] = htons(naddr);
 
-		a = ntohl(ip->ip_dst.s_addr);
-		if (a < g->dst_ip.end) { /* just inc, no wrap */
-			ip->ip_dst.s_addr = htonl(a + 1);
+		/* update checksums if needed */
+		if (g->softchecksum) {
+			if (oaddr != naddr)
+				udp_sum = cksum_add(~oaddr, naddr);
+			if (oport != nport)
+				udp_sum = cksum_add(udp_sum,
+					cksum_add(~oport, nport));
+		}
+		group = g->dst_ip.ipv6.egroup;
+		naddr = oaddr = ntohs(ip6->ip6_dst.s6_addr16[group]);
+		nport = oport = ntohs(udp->uh_dport);
+		if (g->options & OPT_RANDOM_DST) {
+			naddr = ip6->ip6_dst.s6_addr16[group] = random();
+			nport = udp->uh_dport = random();
 			break;
 		}
+		if (oport < g->dst_ip.port1) {
+			nport = oport + 1;
+			udp->uh_dport = htons(nport);
+			break;
+		}
+		nport = g->dst_ip.port0;
+		udp->uh_dport = htons(nport);
+		if (oaddr < ntohs(g->dst_ip.ipv6.end.s6_addr16[group])) {
+			naddr = oaddr + 1;
+			ip6->ip6_dst.s6_addr16[group] = htons(naddr);
+			break;
+		}
+		naddr = ntohs(g->dst_ip.ipv6.start.s6_addr16[group]);
+		ip6->ip6_dst.s6_addr16[group] = htons(naddr);
+	} while (0);
+	/* update checksums */
+	if (g->softchecksum) {
+		if (oaddr != naddr)
+			udp_sum = cksum_add(udp_sum,
+				cksum_add(~oaddr, naddr));
+		if (oport != nport)
+			udp_sum = cksum_add(udp_sum,
+				cksum_add(~oport, nport));
+		if (udp_sum != 0)
+			udp->uh_sum = cksum_add(udp->uh_sum, ~htons(udp_sum));
 	}
-	ip->ip_dst.s_addr = htonl(g->dst_ip.start);
-    } while (0);
-    // update checksum
 }
 
+static void
+update_addresses(struct pkt *pkt, struct glob_arg *g)
+{
+	if (g->af == AF_INET)
+		 update_ip(pkt, g);
+	else
+		update_ip6(pkt, g);
+}
 /*
  * initialize one packet and prepare for the next one.
  * The copy could be done better instead of repeating it each time.
@@ -622,18 +936,23 @@
 {
 	struct pkt *pkt = &targ->pkt;
 	struct ether_header *eh;
+	struct ip6_hdr *ip6;
 	struct ip *ip;
 	struct udphdr *udp;
-	uint16_t paylen = targ->g->pkt_size - sizeof(*eh) - sizeof(struct ip);
+	uint16_t paylen;
+	uint32_t csum;
 	const char *payload = targ->g->options & OPT_INDIRECT ?
 		indirect_payload : default_payload;
 	int i, l0 = strlen(payload);
 
+#ifndef NO_PCAP
 	char errbuf[PCAP_ERRBUF_SIZE];
 	pcap_t *file;
 	struct pcap_pkthdr *header;
 	const unsigned char *packet;
-	
+
+	paylen = targ->g->pkt_size - sizeof(*eh) -
+		(targ->g->af == AF_INET ? sizeof(*ip): sizeof(*ip6));	
 	/* Read a packet from a PCAP file if asked. */
 	if (targ->g->packet_file != NULL) {
 		if ((file = pcap_open_offline(targ->g->packet_file,
@@ -650,84 +969,78 @@
 		pcap_close(file);
 		return;
 	}
+#endif
 
 	/* create a nice NUL-terminated string */
 	for (i = 0; i < paylen; i += l0) {
 		if (l0 > paylen - i)
 			l0 = paylen - i; // last round
-		bcopy(payload, pkt->body + i, l0);
+		bcopy(payload, PKT(pkt, body, targ->g->af) + i, l0);
 	}
-	pkt->body[i-1] = '\0';
-	ip = &pkt->ip;
+	PKT(pkt, body, targ->g->af)[i - 1] = '\0';
 
 	/* prepare the headers */
-        ip->ip_v = IPVERSION;
-        ip->ip_hl = 5;
-        ip->ip_id = 0;
-        ip->ip_tos = IPTOS_LOWDELAY;
-	ip->ip_len = ntohs(targ->g->pkt_size - sizeof(*eh));
-        ip->ip_id = 0;
-        ip->ip_off = htons(IP_DF); /* Don't fragment */
-        ip->ip_ttl = IPDEFTTL;
-	ip->ip_p = IPPROTO_UDP;
-	ip->ip_dst.s_addr = htonl(targ->g->dst_ip.start);
-	ip->ip_src.s_addr = htonl(targ->g->src_ip.start);
-	ip->ip_sum = wrapsum(checksum(ip, sizeof(*ip), 0));
 
-
-	udp = &pkt->udp;
-        udp->uh_sport = htons(targ->g->src_ip.port0);
-        udp->uh_dport = htons(targ->g->dst_ip.port0);
-	udp->uh_ulen = htons(paylen);
-	/* Magic: taken from sbin/dhclient/packet.c */
-	udp->uh_sum = wrapsum(checksum(udp, sizeof(*udp),
-                    checksum(pkt->body,
-                        paylen - sizeof(*udp),
-                        checksum(&ip->ip_src, 2 * sizeof(ip->ip_src),
-                            IPPROTO_UDP + (u_int32_t)ntohs(udp->uh_ulen)
-                        )
-                    )
-                ));
-
 	eh = &pkt->eh;
 	bcopy(&targ->g->src_mac.start, eh->ether_shost, 6);
 	bcopy(&targ->g->dst_mac.start, eh->ether_dhost, 6);
-	eh->ether_type = htons(ETHERTYPE_IP);
 
-	bzero(&pkt->vh, sizeof(pkt->vh));
-#ifdef TRASH_VHOST_HDR
-	/* set bogus content */
-	pkt->vh.fields[0] = 0xff;
-	pkt->vh.fields[1] = 0xff;
-	pkt->vh.fields[2] = 0xff;
-	pkt->vh.fields[3] = 0xff;
-	pkt->vh.fields[4] = 0xff;
-	pkt->vh.fields[5] = 0xff;
-#endif /* TRASH_VHOST_HDR */
-	// dump_payload((void *)pkt, targ->g->pkt_size, NULL, 0);
-}
+	if (targ->g->af == AF_INET) {
+		eh->ether_type = htons(ETHERTYPE_IP);
+		ip = &pkt->ipv4.ip;
+		udp = &pkt->ipv4.udp;
+		ip->ip_v = IPVERSION;
+		ip->ip_hl = sizeof(*ip) >> 2;
+		ip->ip_id = 0;
+		ip->ip_tos = IPTOS_LOWDELAY;
+		ip->ip_len = ntohs(targ->g->pkt_size - sizeof(*eh));
+		ip->ip_id = 0;
+		ip->ip_off = htons(IP_DF); /* Don't fragment */
+		ip->ip_ttl = IPDEFTTL;
+		ip->ip_p = IPPROTO_UDP;
+		ip->ip_dst.s_addr = htonl(targ->g->dst_ip.ipv4.start);
+		ip->ip_src.s_addr = htonl(targ->g->src_ip.ipv4.start);
+		ip->ip_sum = wrapsum(checksum(ip, sizeof(*ip), 0));
+	} else {
+		eh->ether_type = htons(ETHERTYPE_IPV6);
+		ip6 = &pkt->ipv6.ip;
+		udp = &pkt->ipv6.udp;
+		ip6->ip6_flow = 0;
+		ip6->ip6_plen = htons(paylen);
+		ip6->ip6_vfc = IPV6_VERSION;
+		ip6->ip6_nxt = IPPROTO_UDP;
+		ip6->ip6_hlim = IPV6_DEFHLIM;
+		ip6->ip6_src = targ->g->src_ip.ipv6.start;
+		ip6->ip6_dst = targ->g->dst_ip.ipv6.start;
+	}
 
-static void
-set_vnet_hdr_len(struct targ *t)
-{
-	int err, l = t->g->virt_header;
-	struct nmreq req;
+	udp->uh_sport = htons(targ->g->src_ip.port0);
+	udp->uh_dport = htons(targ->g->dst_ip.port0);
+	udp->uh_ulen = htons(paylen);
+	if (targ->g->af == AF_INET) {
+		/* Magic: taken from sbin/dhclient/packet.c */
+		udp->uh_sum = wrapsum(
+			checksum(udp, sizeof(*udp), /* udp header */
+				checksum(pkt->ipv4.body,   /* udp payload */
+			paylen - sizeof(*udp),
+			checksum(&pkt->ipv4.ip.ip_src, /* pseudo header */
+			2 * sizeof(pkt->ipv4.ip.ip_src),
+			IPPROTO_UDP + (u_int32_t)ntohs(udp->uh_ulen)))));
+	} else {
+		/* Save part of pseudo header checksum into csum */
+		csum = IPPROTO_UDP << 24;
+		csum = checksum(&csum, sizeof(csum), paylen);
+		udp->uh_sum = wrapsum(
+			checksum(udp, sizeof(*udp), /* udp header */
+			checksum(pkt->ipv6.body,    /* udp payload */
+			paylen - sizeof(*udp),
+			checksum(&pkt->ipv6.ip.ip6_src, /* pseudo header */
+			2 * sizeof(pkt->ipv6.ip.ip6_src), csum))));
+	}
 
-	if (l == 0)
-		return;
-
-	memset(&req, 0, sizeof(req));
-	bcopy(t->nmd->req.nr_name, req.nr_name, sizeof(req.nr_name));
-	req.nr_version = NETMAP_API;
-	req.nr_cmd = NETMAP_BDG_VNET_HDR;
-	req.nr_arg1 = l;
-	err = ioctl(t->fd, NIOCREGIF, &req);
-	if (err) {
-		D("Unable to set vnet header length %d", l);
-	}
+	// dump_payload((void *)pkt, targ->g->pkt_size, NULL, 0);
 }
 
-
 /*
  * create and enqueue a batch of packets on a ring.
  * On the last one set NS_REPORT to tell the driver to generate
@@ -763,12 +1076,15 @@
 	for (fcnt = nfrags, sent = 0; sent < count; sent++) {
 		struct netmap_slot *slot = &ring->slot[cur];
 		char *p = NETMAP_BUF(ring, slot->buf_idx);
+		int buf_changed = slot->flags & NS_BUF_CHANGED;
 
 		slot->flags = 0;
-		if (options & OPT_INDIRECT) {
+		if (options & OPT_RUBBISH) {
+			/* do nothing */
+		} else if (options & OPT_INDIRECT) {
 			slot->flags |= NS_INDIRECT;
-			slot->ptr = (uint64_t)frame;
-		} else if (options & OPT_COPY) {
+			slot->ptr = (uint64_t)((uintptr_t)frame);
+		} else if ((options & OPT_COPY) || buf_changed) {
 			nm_pkt_copy(frame, p, size);
 			if (fcnt == nfrags)
 				update_addresses(pkt, g);
@@ -798,6 +1114,21 @@
 }
 
 /*
+ * Index of the highest bit set
+ */
+uint32_t
+msb64(uint64_t x)
+{
+	uint64_t m = 1ULL << 63;
+	int i;
+
+	for (i = 63; i >= 0; i--, m >>=1)
+		if (m & x)
+			return i;
+	return 0;
+}
+
+/*
  * Send a packet, and wait for a response.
  * The payload (after UDP header, ofs 42) has a 4-byte sequence
  * followed by a struct timeval (or bintime?)
@@ -810,25 +1141,27 @@
 	struct targ *targ = (struct targ *) data;
 	struct pollfd pfd = { .fd = targ->fd, .events = POLLIN };
 	struct netmap_if *nifp = targ->nmd->nifp;
-	int i, rx = 0, n = targ->g->npackets;
+	int i, rx = 0;
 	void *frame;
 	int size;
-	uint32_t sent = 0;
 	struct timespec ts, now, last_print;
-	uint32_t count = 0, min = 1000000000, av = 0;
+	uint64_t sent = 0, n = targ->g->npackets;
+	uint64_t count = 0, t_cur, t_min = ~0, av = 0;
+	uint64_t buckets[64];	/* bins for delays, ns */
 
 	frame = &targ->pkt;
-	frame += sizeof(targ->pkt.vh) - targ->g->virt_header;
-	size = targ->g->pkt_size + targ->g->virt_header;
+	size = targ->g->pkt_size;
 
+
 	if (targ->g->nthreads > 1) {
 		D("can only ping with 1 thread");
 		return NULL;
 	}
 
+	bzero(&buckets, sizeof(buckets));
 	clock_gettime(CLOCK_REALTIME_PRECISE, &last_print);
 	now = last_print;
-	while (n == 0 || (int)sent < n) {
+	while (!targ->cancel && (n == 0 || sent < n)) {
 		struct netmap_ring *ring = NETMAP_TXRING(nifp, 0);
 		struct netmap_slot *slot;
 		char *p;
@@ -864,6 +1197,8 @@
 			while (!nm_ring_empty(ring)) {
 				uint32_t seq;
 				struct tstamp *tp;
+				int pos;
+
 				slot = &ring->slot[ring->cur];
 				p = NETMAP_BUF(ring, slot->buf_idx);
 
@@ -878,12 +1213,16 @@
 					ts.tv_nsec += 1000000000;
 					ts.tv_sec--;
 				}
-				if (1) D("seq %d/%d delta %d.%09d", seq, sent,
+				if (0) D("seq %d/%lu delta %d.%09d", seq, sent,
 					(int)ts.tv_sec, (int)ts.tv_nsec);
-				if (ts.tv_nsec < (int)min)
-					min = ts.tv_nsec;
+				t_cur = ts.tv_sec * 1000000000UL + ts.tv_nsec;
+				if (t_cur < t_min)
+					t_min = t_cur;
 				count ++;
-				av += ts.tv_nsec;
+				av += t_cur;
+				pos = msb64(t_cur);
+				buckets[pos]++;
+				/* now store it in a bucket */
 				ring->head = ring->cur = nm_ring_next(ring, ring->cur);
 				rx++;
 			}
@@ -897,14 +1236,32 @@
 			ts.tv_sec--;
 		}
 		if (ts.tv_sec >= 1) {
-			D("count %d min %d av %d",
-				count, min, av/count);
+			D("count %d RTT: min %d av %d ns",
+				(int)count, (int)t_min, (int)(av/count));
+			int k, j, kmin;
+			char buf[512];
+
+			for (kmin = 0; kmin < 64; kmin ++)
+				if (buckets[kmin])
+					break;
+			for (k = 63; k >= kmin; k--)
+				if (buckets[k])
+					break;
+			buf[0] = '\0';
+			for (j = kmin; j <= k; j++)
+				sprintf(buf, "%s %5d", buf, (int)buckets[j]);
+			D("k: %d .. %d\n\t%s", 1<<kmin, 1<<k, buf);
+			bzero(&buckets, sizeof(buckets));
 			count = 0;
 			av = 0;
-			min = 100000000;
+			t_min = ~0;
 			last_print = now;
 		}
 	}
+
+	/* reset the ``used`` flag. */
+	targ->used = 0;
+
 	return NULL;
 }
 
@@ -919,14 +1276,15 @@
 	struct pollfd pfd = { .fd = targ->fd, .events = POLLIN };
 	struct netmap_if *nifp = targ->nmd->nifp;
 	struct netmap_ring *txring, *rxring;
-	int i, rx = 0, sent = 0, n = targ->g->npackets;
+	int i, rx = 0;
+	uint64_t sent = 0, n = targ->g->npackets;
 
 	if (targ->g->nthreads > 1) {
 		D("can only reply ping with 1 thread");
 		return NULL;
 	}
-	D("understood ponger %d but don't know how to do it", n);
-	while (n == 0 || sent < n) {
+	D("understood ponger %lu but don't know how to do it", n);
+	while (!targ->cancel && (n == 0 || sent < n)) {
 		uint32_t txcur, txavail;
 //#define BUSYWAIT
 #ifdef BUSYWAIT
@@ -975,72 +1333,20 @@
 			}
 		}
 		txring->head = txring->cur = txcur;
-		targ->count = sent;
+		targ->ctr.pkts = sent;
 #ifdef BUSYWAIT
 		ioctl(pfd.fd, NIOCTXSYNC, NULL);
 #endif
 		//D("tx %d rx %d", sent, rx);
 	}
-	return NULL;
-}
 
-static __inline int
-timespec_ge(const struct timespec *a, const struct timespec *b)
-{
+	/* reset the ``used`` flag. */
+	targ->used = 0;
 
-	if (a->tv_sec > b->tv_sec)
-		return (1);
-	if (a->tv_sec < b->tv_sec)
-		return (0);
-	if (a->tv_nsec >= b->tv_nsec)
-		return (1);
-	return (0);
+	return NULL;
 }
 
-static __inline struct timespec
-timeval2spec(const struct timeval *a)
-{
-	struct timespec ts = {
-		.tv_sec = a->tv_sec,
-		.tv_nsec = a->tv_usec * 1000
-	};
-	return ts;
-}
 
-static __inline struct timeval
-timespec2val(const struct timespec *a)
-{
-	struct timeval tv = {
-		.tv_sec = a->tv_sec,
-		.tv_usec = a->tv_nsec / 1000
-	};
-	return tv;
-}
-
-
-static __inline struct timespec
-timespec_add(struct timespec a, struct timespec b)
-{
-	struct timespec ret = { a.tv_sec + b.tv_sec, a.tv_nsec + b.tv_nsec };
-	if (ret.tv_nsec >= 1000000000) {
-		ret.tv_sec++;
-		ret.tv_nsec -= 1000000000;
-	}
-	return ret;
-}
-
-static __inline struct timespec
-timespec_sub(struct timespec a, struct timespec b)
-{
-	struct timespec ret = { a.tv_sec - b.tv_sec, a.tv_nsec - b.tv_nsec };
-	if (ret.tv_nsec < 0) {
-		ret.tv_sec--;
-		ret.tv_nsec += 1000000000;
-	}
-	return ret;
-}
-
-
 /*
  * wait until ts, either busy or sleeping if more than 1ms.
  * Return wakeup time.
@@ -1065,9 +1371,11 @@
 	struct targ *targ = (struct targ *) data;
 	struct pollfd pfd = { .fd = targ->fd, .events = POLLOUT };
 	struct netmap_if *nifp;
-	struct netmap_ring *txring;
-	int i, n = targ->g->npackets / targ->g->nthreads;
-	int64_t sent = 0;
+	struct netmap_ring *txring = NULL;
+	int i;
+	uint64_t n = targ->g->npackets / targ->g->nthreads;
+	uint64_t sent = 0;
+	uint64_t event = 0;
 	int options = targ->g->options | OPT_COPY;
 	struct timespec nexttime = { 0, 0}; // XXX silence compiler
 	int rate_limit = targ->g->tx_rate;
@@ -1077,8 +1385,7 @@
 
 	if (targ->frame == NULL) {
 		frame = pkt;
-		frame += sizeof(pkt->vh) - targ->g->virt_header;
-		size = targ->g->pkt_size + targ->g->virt_header;
+		size = targ->g->pkt_size;
 	} else {
 		frame = targ->frame;
 		size = targ->g->pkt_size;
@@ -1104,7 +1411,9 @@
 			sent++;
 		update_addresses(pkt, targ->g);
 		if (i > 10000) {
-			targ->count = sent;
+			targ->ctr.pkts = sent;
+			targ->ctr.bytes = sent*size;
+			targ->ctr.events = sent;
 			i = 0;
 		}
 	    }
@@ -1117,7 +1426,9 @@
 			sent++;
 		update_addresses(pkt, targ->g);
 		if (i > 10000) {
-			targ->count = sent;
+			targ->ctr.pkts = sent;
+			targ->ctr.bytes = sent*size;
+			targ->ctr.events = sent;
 			i = 0;
 		}
 	    }
@@ -1126,7 +1437,7 @@
 	int tosend = 0;
 	int frags = targ->g->frags;
 
-        nifp = targ->nmd->nifp;
+	nifp = targ->nmd->nifp;
 	while (!targ->cancel && (n == 0 || sent < n)) {
 
 		if (rate_limit && tosend <= 0) {
@@ -1138,6 +1449,13 @@
 		/*
 		 * wait for available room in the send queue(s)
 		 */
+#ifdef BUSYWAIT
+		if (ioctl(pfd.fd, NIOCTXSYNC, NULL) < 0) {
+			D("ioctl error on queue %d: %s", targ->me,
+					strerror(errno));
+			goto quit;
+		}
+#else /* !BUSYWAIT */
 		if (poll(&pfd, 1, 2000) <= 0) {
 			if (targ->cancel)
 				break;
@@ -1146,9 +1464,11 @@
 			// goto quit;
 		}
 		if (pfd.revents & POLLERR) {
-			D("poll error");
+			D("poll error on %d ring %d-%d", pfd.fd,
+				targ->nmd->first_tx_ring, targ->nmd->last_tx_ring);
 			goto quit;
 		}
+#endif /* !BUSYWAIT */
 		/*
 		 * scan our queues and send on those with room
 		 */
@@ -1157,7 +1477,8 @@
 			options &= ~OPT_COPY;
 		}
 		for (i = targ->nmd->first_tx_ring; i <= targ->nmd->last_tx_ring; i++) {
-			int m, limit = rate_limit ?  tosend : targ->g->burst;
+			int m;
+			uint64_t limit = rate_limit ?  tosend : targ->g->burst;
 			if (n > 0 && n - sent < limit)
 				limit = n - sent;
 			txring = NETMAP_TXRING(nifp, i);
@@ -1171,7 +1492,11 @@
 			ND("limit %d tail %d frags %d m %d",
 				limit, txring->tail, frags, m);
 			sent += m;
-			targ->count = sent;
+			if (m > 0) //XXX-ste: can m be 0?
+				event++;
+			targ->ctr.pkts = sent;
+			targ->ctr.bytes = sent*size;
+			targ->ctr.events = event;
 			if (rate_limit) {
 				tosend -= m;
 				if (tosend <= 0)
@@ -1182,13 +1507,13 @@
 	/* flush any remaining packets */
 	D("flush tail %d head %d on thread %p",
 		txring->tail, txring->head,
-		pthread_self());
+		(void *)pthread_self());
 	ioctl(pfd.fd, NIOCTXSYNC, NULL);
 
 	/* final part: wait all the TX queues to be empty. */
 	for (i = targ->nmd->first_tx_ring; i <= targ->nmd->last_tx_ring; i++) {
 		txring = NETMAP_TXRING(nifp, i);
-		while (nm_tx_pending(txring)) {
+		while (!targ->cancel && nm_tx_pending(txring)) {
 			RD(5, "pending tx tail %d head %d on ring %d",
 				txring->tail, txring->head, i);
 			ioctl(pfd.fd, NIOCTXSYNC, NULL);
@@ -1199,8 +1524,9 @@
 
 	clock_gettime(CLOCK_REALTIME_PRECISE, &targ->toc);
 	targ->completed = 1;
-	targ->count = sent;
-
+	targ->ctr.pkts = sent;
+	targ->ctr.bytes = sent*size;
+	targ->ctr.events = event;
 quit:
 	/* reset the ``used`` flag. */
 	targ->used = 0;
@@ -1214,18 +1540,23 @@
 receive_pcap(u_char *user, const struct pcap_pkthdr * h,
 	const u_char * bytes)
 {
-	int *count = (int *)user;
-	(void)h;	/* UNUSED */
+	struct my_ctrs *ctr = (struct my_ctrs *)user;
 	(void)bytes;	/* UNUSED */
-	(*count)++;
+	ctr->bytes += h->len;
+	ctr->pkts++;
 }
 #endif /* !NO_PCAP */
 
+
 static int
-receive_packets(struct netmap_ring *ring, u_int limit, int dump)
+receive_packets(struct netmap_ring *ring, u_int limit, int dump, uint64_t *bytes)
 {
 	u_int cur, rx, n;
+	uint64_t b = 0;
 
+	if (bytes == NULL)
+		bytes = &b;
+
 	cur = ring->cur;
 	n = nm_ring_space(ring);
 	if (n < limit)
@@ -1234,6 +1565,7 @@
 		struct netmap_slot *slot = &ring->slot[cur];
 		char *p = NETMAP_BUF(ring, slot->buf_idx);
 
+		*bytes += slot->len;
 		if (dump)
 			dump_payload(p, slot->len, ring, cur);
 
@@ -1252,8 +1584,11 @@
 	struct netmap_if *nifp;
 	struct netmap_ring *rxring;
 	int i;
-	uint64_t received = 0;
+	struct my_ctrs cur;
 
+	cur.pkts = cur.bytes = cur.events = cur.min_space = 0;
+	cur.t.tv_usec = cur.t.tv_sec = 0; //  unused, just silence the compiler
+
 	if (setaffinity(targ->thread, targ->affinity))
 		goto quit;
 
@@ -1273,8 +1608,12 @@
 	while (!targ->cancel) {
 		char buf[MAX_BODYSIZE];
 		/* XXX should we poll ? */
-		if (read(targ->g->main_fd, buf, sizeof(buf)) > 0)
-			targ->count++;
+		i = read(targ->g->main_fd, buf, sizeof(buf));
+		if (i > 0) {
+			targ->ctr.pkts++;
+			targ->ctr.bytes += i;
+			targ->ctr.events++;
+		}
 	}
 #ifndef NO_PCAP
     } else if (targ->g->dev_type == DEV_PCAP) {
@@ -1281,16 +1620,24 @@
 	while (!targ->cancel) {
 		/* XXX should we poll ? */
 		pcap_dispatch(targ->g->p, targ->g->burst, receive_pcap,
-			(u_char *)&targ->count);
+			(u_char *)&targ->ctr);
+                targ->ctr.events++;
 	}
 #endif /* !NO_PCAP */
     } else {
 	int dump = targ->g->options & OPT_DUMP;
 
-        nifp = targ->nmd->nifp;
+	nifp = targ->nmd->nifp;
 	while (!targ->cancel) {
 		/* Once we started to receive packets, wait at most 1 seconds
 		   before quitting. */
+#ifdef BUSYWAIT
+		if (ioctl(pfd.fd, NIOCRXSYNC, NULL) < 0) {
+			D("ioctl error on queue %d: %s", targ->me,
+					strerror(errno));
+			goto quit;
+		}
+#else /* !BUSYWAIT */
 		if (poll(&pfd, 1, 1 * 1000) <= 0 && !targ->g->forever) {
 			clock_gettime(CLOCK_REALTIME_PRECISE, &targ->toc);
 			targ->toc.tv_sec -= 1; /* Subtract timeout time. */
@@ -1301,26 +1648,39 @@
 			D("poll err");
 			goto quit;
 		}
-
+#endif /* !BUSYWAIT */
+		uint64_t cur_space = 0;
 		for (i = targ->nmd->first_rx_ring; i <= targ->nmd->last_rx_ring; i++) {
 			int m;
 
 			rxring = NETMAP_RXRING(nifp, i);
+			/* compute free space in the ring */
+			m = rxring->head + rxring->num_slots - rxring->tail;
+			if (m >= (int) rxring->num_slots)
+				m -= rxring->num_slots;
+			cur_space += m;
 			if (nm_ring_empty(rxring))
 				continue;
 
-			m = receive_packets(rxring, targ->g->burst, dump);
-			received += m;
+			m = receive_packets(rxring, targ->g->burst, dump, &cur.bytes);
+			cur.pkts += m;
+			if (m > 0) //XXX-ste: can m be 0?
+				cur.events++;
 		}
-		targ->count = received;
+		cur.min_space = targ->ctr.min_space;
+		if (cur_space < cur.min_space)
+			cur.min_space = cur_space;
+		targ->ctr = cur;
 	}
     }
 
 	clock_gettime(CLOCK_REALTIME_PRECISE, &targ->toc);
 
+#if !defined(BUSYWAIT)
 out:
+#endif
 	targ->completed = 1;
-	targ->count = received;
+	targ->ctr = cur;
 
 quit:
 	/* reset the ``used`` flag. */
@@ -1329,56 +1689,395 @@
 	return (NULL);
 }
 
-/* very crude code to print a number in normalized form.
- * Caller has to make sure that the buffer is large enough.
- */
-static const char *
-norm(char *buf, double val)
+static void *
+txseq_body(void *data)
 {
-	char *units[] = { "", "K", "M", "G", "T" };
-	u_int i;
+	struct targ *targ = (struct targ *) data;
+	struct pollfd pfd = { .fd = targ->fd, .events = POLLOUT };
+	struct netmap_ring *ring;
+	int64_t sent = 0;
+	uint64_t event = 0;
+	int options = targ->g->options | OPT_COPY;
+	struct timespec nexttime = {0, 0};
+	int rate_limit = targ->g->tx_rate;
+	struct pkt *pkt = &targ->pkt;
+	int frags = targ->g->frags;
+	uint32_t sequence = 0;
+	int budget = 0;
+	void *frame;
+	int size;
 
-	for (i = 0; val >=1000 && i < sizeof(units)/sizeof(char *) - 1; i++)
-		val /= 1000;
-	sprintf(buf, "%.2f %s", val, units[i]);
-	return buf;
+	if (targ->g->nthreads > 1) {
+		D("can only txseq ping with 1 thread");
+		return NULL;
+	}
+
+	if (targ->g->npackets > 0) {
+		D("Ignoring -n argument");
+	}
+
+	frame = pkt;
+	size = targ->g->pkt_size;
+
+	D("start, fd %d main_fd %d", targ->fd, targ->g->main_fd);
+	if (setaffinity(targ->thread, targ->affinity))
+		goto quit;
+
+	clock_gettime(CLOCK_REALTIME_PRECISE, &targ->tic);
+	if (rate_limit) {
+		targ->tic = timespec_add(targ->tic, (struct timespec){2,0});
+		targ->tic.tv_nsec = 0;
+		wait_time(targ->tic);
+		nexttime = targ->tic;
+	}
+
+	/* Only use the first queue. */
+	ring = NETMAP_TXRING(targ->nmd->nifp, targ->nmd->first_tx_ring);
+
+	while (!targ->cancel) {
+		int64_t limit;
+		unsigned int space;
+		unsigned int head;
+		int fcnt;
+
+		if (!rate_limit) {
+			budget = targ->g->burst;
+
+		} else if (budget <= 0) {
+			budget = targ->g->burst;
+			nexttime = timespec_add(nexttime, targ->g->tx_period);
+			wait_time(nexttime);
+		}
+
+		/* wait for available room in the send queue */
+		if (poll(&pfd, 1, 2000) <= 0) {
+			if (targ->cancel)
+				break;
+			D("poll error/timeout on queue %d: %s", targ->me,
+				strerror(errno));
+		}
+		if (pfd.revents & POLLERR) {
+			D("poll error on %d ring %d-%d", pfd.fd,
+				targ->nmd->first_tx_ring, targ->nmd->last_tx_ring);
+			goto quit;
+		}
+
+		/* If no room poll() again. */
+		space = nm_ring_space(ring);
+		if (!space) {
+			continue;
+		}
+
+		limit = budget;
+
+		if (space < limit) {
+			limit = space;
+		}
+
+		/* Cut off ``limit`` to make sure is multiple of ``frags``. */
+		if (frags > 1) {
+			limit = (limit / frags) * frags;
+		}
+
+		limit = sent + limit; /* Convert to absolute. */
+
+		for (fcnt = frags, head = ring->head;
+				sent < limit; sent++, sequence++) {
+			struct netmap_slot *slot = &ring->slot[head];
+			char *p = NETMAP_BUF(ring, slot->buf_idx);
+
+			slot->flags = 0;
+			PKT(pkt, body, targ->g->af)[0] = sequence >> 24;
+			PKT(pkt, body, targ->g->af)[1] = (sequence >> 16) & 0xff;
+			PKT(pkt, body, targ->g->af)[2] = (sequence >> 8) & 0xff;
+			PKT(pkt, body, targ->g->af)[3] = sequence & 0xff;
+			nm_pkt_copy(frame, p, size);
+			if (fcnt == frags) {
+				update_addresses(pkt, targ->g);
+			}
+
+			if (options & OPT_DUMP) {
+				dump_payload(p, size, ring, head);
+			}
+
+			slot->len = size;
+
+			if (--fcnt > 0) {
+				slot->flags |= NS_MOREFRAG;
+			} else {
+				fcnt = frags;
+			}
+
+			if (sent == limit - 1) {
+				/* Make sure we don't push an incomplete
+				 * packet. */
+				assert(!(slot->flags & NS_MOREFRAG));
+				slot->flags |= NS_REPORT;
+			}
+
+			head = nm_ring_next(ring, head);
+			if (rate_limit) {
+				budget--;
+			}
+		}
+
+		ring->cur = ring->head = head;
+
+		event ++;
+		targ->ctr.pkts = sent;
+		targ->ctr.bytes = sent * size;
+		targ->ctr.events = event;
+	}
+
+	/* flush any remaining packets */
+	D("flush tail %d head %d on thread %p",
+		ring->tail, ring->head,
+		(void *)pthread_self());
+	ioctl(pfd.fd, NIOCTXSYNC, NULL);
+
+	/* final part: wait the TX queues to become empty. */
+	while (!targ->cancel && nm_tx_pending(ring)) {
+		RD(5, "pending tx tail %d head %d on ring %d",
+				ring->tail, ring->head, targ->nmd->first_tx_ring);
+		ioctl(pfd.fd, NIOCTXSYNC, NULL);
+		usleep(1); /* wait 1 tick */
+	}
+
+	clock_gettime(CLOCK_REALTIME_PRECISE, &targ->toc);
+	targ->completed = 1;
+	targ->ctr.pkts = sent;
+	targ->ctr.bytes = sent * size;
+	targ->ctr.events = event;
+quit:
+	/* reset the ``used`` flag. */
+	targ->used = 0;
+
+	return (NULL);
 }
 
-static void
-tx_output(uint64_t sent, int size, double delta)
+
+static char *
+multi_slot_to_string(struct netmap_ring *ring, unsigned int head,
+		     unsigned int nfrags, char *strbuf, size_t strbuflen)
 {
-	double bw, raw_bw, pps;
-	char b1[40], b2[80], b3[80];
+	unsigned int f;
+	char *ret = strbuf;
 
-	printf("Sent %llu packets, %d bytes each, in %.2f seconds.\n",
-	       (unsigned long long)sent, size, delta);
-	if (delta == 0)
-		delta = 1e-6;
-	if (size < 60)		/* correct for min packet size */
-		size = 60;
-	pps = sent / delta;
-	bw = (8.0 * size * sent) / delta;
-	/* raw packets have4 bytes crc + 20 bytes framing */
-	raw_bw = (8.0 * (size + 24) * sent) / delta;
+	for (f = 0; f < nfrags; f++) {
+		struct netmap_slot *slot = &ring->slot[head];
+		int m = snprintf(strbuf, strbuflen, "|%u,%x|", slot->len,
+				 slot->flags);
+		if (m >= (int)strbuflen) {
+			break;
+		}
+		strbuf += m;
+		strbuflen -= m;
 
-	printf("Speed: %spps Bandwidth: %sbps (raw %sbps)\n",
-		norm(b1, pps), norm(b2, bw), norm(b3, raw_bw) );
+		head = nm_ring_next(ring, head);
+	}
+
+	return ret;
 }
 
+static void *
+rxseq_body(void *data)
+{
+	struct targ *targ = (struct targ *) data;
+	struct pollfd pfd = { .fd = targ->fd, .events = POLLIN };
+	int dump = targ->g->options & OPT_DUMP;
+	struct netmap_ring *ring;
+	unsigned int frags_exp = 1;
+	uint32_t seq_exp = 0;
+	struct my_ctrs cur;
+	unsigned int frags = 0;
+	int first_packet = 1;
+	int first_slot = 1;
+	int i, af;
 
+	cur.pkts = cur.bytes = cur.events = cur.min_space = 0;
+	cur.t.tv_usec = cur.t.tv_sec = 0; //  unused, just silence the compiler
+
+	if (setaffinity(targ->thread, targ->affinity))
+		goto quit;
+
+	D("reading from %s fd %d main_fd %d",
+		targ->g->ifname, targ->fd, targ->g->main_fd);
+	/* unbounded wait for the first packet. */
+	for (;!targ->cancel;) {
+		i = poll(&pfd, 1, 1000);
+		if (i > 0 && !(pfd.revents & POLLERR))
+			break;
+		RD(1, "waiting for initial packets, poll returns %d %d",
+			i, pfd.revents);
+	}
+
+	clock_gettime(CLOCK_REALTIME_PRECISE, &targ->tic);
+
+	ring = NETMAP_RXRING(targ->nmd->nifp, targ->nmd->first_rx_ring);
+
+	while (!targ->cancel) {
+		unsigned int head;
+		uint32_t seq;
+		int limit;
+
+		/* Once we started to receive packets, wait at most 1 seconds
+		   before quitting. */
+		if (poll(&pfd, 1, 1 * 1000) <= 0 && !targ->g->forever) {
+			clock_gettime(CLOCK_REALTIME_PRECISE, &targ->toc);
+			targ->toc.tv_sec -= 1; /* Subtract timeout time. */
+			goto out;
+		}
+
+		if (pfd.revents & POLLERR) {
+			D("poll err");
+			goto quit;
+		}
+
+		if (nm_ring_empty(ring))
+			continue;
+
+		limit = nm_ring_space(ring);
+		if (limit > targ->g->burst)
+			limit = targ->g->burst;
+
+#if 0
+		/* Enable this if
+		 *     1) we remove the early-return optimization from
+		 *        the netmap poll implementation, or
+		 *     2) pipes get NS_MOREFRAG support.
+		 * With the current netmap implementation, an experiment like
+		 *    pkt-gen -i vale:1{1 -f txseq -F 9
+		 *    pkt-gen -i vale:1}1 -f rxseq
+		 * would get stuck as soon as we find nm_ring_space(ring) < 9,
+		 * since here limit is rounded to 0 and
+		 * pipe rxsync is not called anymore by the poll() of this loop.
+		 */
+		if (frags_exp > 1) {
+			int o = limit;
+			/* Cut off to the closest smaller multiple. */
+			limit = (limit / frags_exp) * frags_exp;
+			RD(2, "LIMIT %d --> %d", o, limit);
+		}
+#endif
+
+		for (head = ring->head, i = 0; i < limit; i++) {
+			struct netmap_slot *slot = &ring->slot[head];
+			char *p = NETMAP_BUF(ring, slot->buf_idx);
+			int len = slot->len;
+			struct pkt *pkt;
+
+			if (dump) {
+				dump_payload(p, slot->len, ring, head);
+			}
+
+			frags++;
+			if (!(slot->flags & NS_MOREFRAG)) {
+				if (first_packet) {
+					first_packet = 0;
+				} else if (frags != frags_exp) {
+					char prbuf[512];
+					RD(1, "Received packets with %u frags, "
+					      "expected %u, '%s'", frags, frags_exp,
+					      multi_slot_to_string(ring, head-frags+1, frags,
+								   prbuf, sizeof(prbuf)));
+				}
+				first_packet = 0;
+				frags_exp = frags;
+				frags = 0;
+			}
+
+			pkt = (struct pkt *)p;
+			if (ntohs(pkt->eh.ether_type) == ETHERTYPE_IP)
+				af = AF_INET;
+			else
+				af = AF_INET6;
+
+			if ((char *)pkt + len < ((char *)PKT(pkt, body, af)) +
+				sizeof(seq)) {
+				RD(1, "%s: packet too small (len=%u)", __func__,
+				      slot->len);
+			} else {
+				seq = (PKT(pkt, body, af)[0] << 24) |
+					(PKT(pkt, body, af)[1] << 16) |
+					(PKT(pkt, body, af)[2] << 8) |
+					PKT(pkt, body, af)[3];
+				if (first_slot) {
+					/* Grab the first one, whatever it
+					   is. */
+					seq_exp = seq;
+					first_slot = 0;
+				} else if (seq != seq_exp) {
+					uint32_t delta = seq - seq_exp;
+
+					if (delta < (0xFFFFFFFF >> 1)) {
+						RD(2, "Sequence GAP: exp %u found %u",
+						      seq_exp, seq);
+					} else {
+						RD(2, "Sequence OUT OF ORDER: "
+						      "exp %u found %u", seq_exp, seq);
+					}
+					seq_exp = seq;
+				}
+				seq_exp++;
+			}
+
+			cur.bytes += slot->len;
+			head = nm_ring_next(ring, head);
+			cur.pkts++;
+		}
+
+		ring->cur = ring->head = head;
+
+		cur.events++;
+		targ->ctr = cur;
+	}
+
+	clock_gettime(CLOCK_REALTIME_PRECISE, &targ->toc);
+
+out:
+	targ->completed = 1;
+	targ->ctr = cur;
+
+quit:
+	/* reset the ``used`` flag. */
+	targ->used = 0;
+
+	return (NULL);
+}
+
+
 static void
-rx_output(uint64_t received, double delta)
+tx_output(struct my_ctrs *cur, double delta, const char *msg)
 {
-	double pps;
-	char b1[40];
+	double bw, raw_bw, pps, abs;
+	char b1[40], b2[80], b3[80];
+	int size;
 
-	printf("Received %llu packets, in %.2f seconds.\n",
-		(unsigned long long) received, delta);
+	if (cur->pkts == 0) {
+		printf("%s nothing.\n", msg);
+		return;
+	}
 
+	size = (int)(cur->bytes / cur->pkts);
+
+	printf("%s %llu packets %llu bytes %llu events %d bytes each in %.2f seconds.\n",
+		msg,
+		(unsigned long long)cur->pkts,
+		(unsigned long long)cur->bytes,
+		(unsigned long long)cur->events, size, delta);
 	if (delta == 0)
 		delta = 1e-6;
-	pps = received / delta;
-	printf("Speed: %spps\n", norm(b1, pps));
+	if (size < 60)		/* correct for min packet size */
+		size = 60;
+	pps = cur->pkts / delta;
+	bw = (8.0 * cur->bytes) / delta;
+	/* raw packets have4 bytes crc + 20 bytes framing */
+	raw_bw = (8.0 * (cur->pkts * 24 + cur->bytes)) / delta;
+	abs = cur->pkts / (double)(cur->events);
+
+	printf("Speed: %spps Bandwidth: %sbps (raw %sbps). Average batch: %.2f pkts\n",
+		norm(b1, pps, normalize), norm(b2, bw, normalize),
+		norm(b3, raw_bw, normalize), abs);
 }
 
 static void
@@ -1389,9 +2088,9 @@
 		"Usage:\n"
 		"%s arguments\n"
 		"\t-i interface		interface name\n"
-		"\t-f function		tx rx ping pong\n"
+		"\t-f function		tx rx ping pong txseq rxseq\n"
 		"\t-n count		number of iterations (can be 0)\n"
-		"\t-t pkts_to_send		also forces tx mode\n"
+		"\t-t pkts_to_send	also forces tx mode\n"
 		"\t-r pkts_to_receive	also forces rx mode\n"
 		"\t-l pkt_size		in bytes excluding CRC\n"
 		"\t-d dst_ip[:port[-dst_ip:port]]   single or range\n"
@@ -1403,14 +2102,21 @@
 		"\t-c cores		cores to use\n"
 		"\t-p threads		processes/threads to use\n"
 		"\t-T report_ms		milliseconds between reports\n"
-		"\t-P			use libpcap instead of netmap\n"
 		"\t-w wait_for_link_time	in seconds\n"
 		"\t-R rate		in packets per second\n"
 		"\t-X			dump payload\n"
-		"\t-H len		add empty virtio-net-header with size 'len'\n"
-	        "\t-P file		load packet from pcap file\n"
+		"\t-E pipes		allocate extra space for a number of pipes\n"
+		"\t-r			do not touch the buffers (send rubbish)\n"
+	    "\t-P file		load packet from pcap file\n"
 		"\t-z			use random IPv4 src address/port\n"
 		"\t-Z			use random IPv4 dst address/port\n"
+		"\t-F num_frags		send multi-slot packets\n"
+		"\t-A			activate pps stats on receiver\n"
+		"\t-N			disable units normalization\n"
+		"\t-U			enable software UDP CRC chekcsum\n"
+		"\t				  mandatory on Intel, useless on Chelsio\n"
+		"\t-4			use inet4 address family\n"
+		"\t-6           use inet6 address family\n"
 		"",
 		cmd);
 
@@ -1417,6 +2123,12 @@
 	exit(0);
 }
 
+enum {
+	TD_TYPE_SENDER = 1,
+	TD_TYPE_RECEIVER,
+	TD_TYPE_OTHER,
+};
+
 static void
 start_threads(struct glob_arg *g)
 {
@@ -1439,33 +2151,32 @@
 		uint64_t nmd_flags = 0;
 		nmd.self = &nmd;
 
-		if (g->nthreads > 1) {
-			if (nmd.req.nr_flags != NR_REG_ALL_NIC) {
-				D("invalid nthreads mode %d", nmd.req.nr_flags);
+		if (i > 0) {
+			/* the first thread uses the fd opened by the main
+			 * thread, the other threads re-open /dev/netmap
+			 */
+			if (g->nthreads > 1) {
+				nmd.req.nr_flags =
+					g->nmd->req.nr_flags & ~NR_REG_MASK;
+				nmd.req.nr_flags |= NR_REG_ONE_NIC;
+				nmd.req.nr_ringid = i;
+			}
+			/* Only touch one of the rings (rx is already ok) */
+			if (g->td_type == TD_TYPE_RECEIVER)
+				nmd_flags |= NETMAP_NO_TX_POLL;
+
+			/* register interface. Override ifname and ringid etc. */
+			t->nmd = nm_open(t->g->ifname, NULL, nmd_flags |
+				NM_OPEN_IFNAME | NM_OPEN_NO_MMAP, &nmd);
+			if (t->nmd == NULL) {
+				D("Unable to open %s: %s",
+					t->g->ifname, strerror(errno));
 				continue;
 			}
-			nmd.req.nr_flags = NR_REG_ONE_NIC;
-			nmd.req.nr_ringid = i;
+		} else {
+			t->nmd = g->nmd;
 		}
-		/* Only touch one of the rings (rx is already ok) */
-		if (g->td_body == receiver_body)
-			nmd_flags |= NETMAP_NO_TX_POLL;
-
-		/* register interface. Override ifname and ringid etc. */
-		if (g->options & OPT_MONITOR_TX)
-			nmd.req.nr_flags |= NR_MONITOR_TX;
-		if (g->options & OPT_MONITOR_RX)
-			nmd.req.nr_flags |= NR_MONITOR_RX;
-
-		t->nmd = nm_open(t->g->ifname, NULL, nmd_flags |
-			NM_OPEN_IFNAME | NM_OPEN_NO_MMAP, &nmd);
-		if (t->nmd == NULL) {
-			D("Unable to open %s: %s",
-				t->g->ifname, strerror(errno));
-			continue;
-		}
 		t->fd = t->nmd->fd;
-		set_vnet_hdr_len(t);
 
 	    } else {
 		targs[i].fd = g->main_fd;
@@ -1473,10 +2184,7 @@
 		t->used = 1;
 		t->me = i;
 		if (g->affinity >= 0) {
-			if (g->affinity < g->cpus)
-				t->affinity = g->affinity;
-			else
-				t->affinity = i % g->cpus;
+			t->affinity = (g->affinity + i) % g->system_cpus;
 		} else {
 			t->affinity = -1;
 		}
@@ -1495,39 +2203,80 @@
 {
 	int i;
 
-	uint64_t prev = 0;
-	uint64_t count = 0;
+	struct my_ctrs prev, cur;
 	double delta_t;
 	struct timeval tic, toc;
 
-	gettimeofday(&toc, NULL);
+	prev.pkts = prev.bytes = prev.events = 0;
+	gettimeofday(&prev.t, NULL);
 	for (;;) {
-		struct timeval now, delta;
-		uint64_t pps, usec, my_count, npkts;
+		char b1[40], b2[40], b3[40], b4[70];
+		uint64_t pps, usec;
+		struct my_ctrs x;
+		double abs;
 		int done = 0;
 
-		delta.tv_sec = g->report_interval/1000;
-		delta.tv_usec = (g->report_interval%1000)*1000;
-		select(0, NULL, NULL, NULL, &delta);
-		gettimeofday(&now, NULL);
-		timersub(&now, &toc, &toc);
-		my_count = 0;
+		usec = wait_for_next_report(&prev.t, &cur.t,
+				g->report_interval);
+
+		cur.pkts = cur.bytes = cur.events = 0;
+		cur.min_space = 0;
+		if (usec < 10000) /* too short to be meaningful */
+			continue;
+		/* accumulate counts for all threads */
 		for (i = 0; i < g->nthreads; i++) {
-			my_count += targs[i].count;
+			cur.pkts += targs[i].ctr.pkts;
+			cur.bytes += targs[i].ctr.bytes;
+			cur.events += targs[i].ctr.events;
+			cur.min_space += targs[i].ctr.min_space;
+			targs[i].ctr.min_space = 99999;
 			if (targs[i].used == 0)
 				done++;
 		}
-		usec = toc.tv_sec* 1000000 + toc.tv_usec;
-		if (usec < 10000)
-			continue;
-		npkts = my_count - prev;
-		pps = (npkts*1000000 + usec/2) / usec;
-		D("%llu pps (%llu pkts in %llu usec)",
-			(unsigned long long)pps,
-			(unsigned long long)npkts,
-			(unsigned long long)usec);
-		prev = my_count;
-		toc = now;
+		x.pkts = cur.pkts - prev.pkts;
+		x.bytes = cur.bytes - prev.bytes;
+		x.events = cur.events - prev.events;
+		pps = (x.pkts*1000000 + usec/2) / usec;
+		abs = (x.events > 0) ? (x.pkts / (double) x.events) : 0;
+
+		if (!(g->options & OPT_PPS_STATS)) {
+			strcpy(b4, "");
+		} else {
+			/* Compute some pps stats using a sliding window. */
+			double ppsavg = 0.0, ppsdev = 0.0;
+			int nsamples = 0;
+
+			g->win[g->win_idx] = pps;
+			g->win_idx = (g->win_idx + 1) % STATS_WIN;
+
+			for (i = 0; i < STATS_WIN; i++) {
+				ppsavg += g->win[i];
+				if (g->win[i]) {
+					nsamples ++;
+				}
+			}
+			ppsavg /= nsamples;
+
+			for (i = 0; i < STATS_WIN; i++) {
+				if (g->win[i] == 0) {
+					continue;
+				}
+				ppsdev += (g->win[i] - ppsavg) * (g->win[i] - ppsavg);
+			}
+			ppsdev /= nsamples;
+			ppsdev = sqrt(ppsdev);
+			snprintf(b4, sizeof(b4), "[avg/std %s/%s pps]",
+				norm(b1, ppsavg, normalize), norm(b2, ppsdev, normalize));
+		}
+
+			D("%spps %s(%spkts %sbps in %llu usec) %.2f avg_batch %d min_space",
+				norm(b1, pps, normalize), b4,
+				norm(b2, (double)x.pkts, normalize),
+				norm(b3, (double)x.bytes*8, normalize),
+				(unsigned long long)usec,
+				abs, (int)cur.min_space);
+		prev = cur;
+
 		if (done == g->nthreads)
 			break;
 	}
@@ -1534,6 +2283,8 @@
 
 	timerclear(&tic);
 	timerclear(&toc);
+	cur.pkts = cur.bytes = cur.events = 0;
+	/* final round */
 	for (i = 0; i < g->nthreads; i++) {
 		struct timespec t_tic, t_toc;
 		/*
@@ -1541,8 +2292,13 @@
 		 * file descriptors.
 		 */
 		if (targs[i].used)
-			pthread_join(targs[i].thread, NULL);
-		close(targs[i].fd);
+			pthread_join(targs[i].thread, NULL); /* blocking */
+		if (g->dev_type == DEV_NETMAP) {
+			nm_close(targs[i].nmd);
+			targs[i].nmd = NULL;
+		} else {
+			close(targs[i].fd);
+		}
 
 		if (targs[i].completed == 0)
 			D("ouch, thread %d exited with error", i);
@@ -1551,7 +2307,13 @@
 		 * Collect threads output and extract information about
 		 * how long it took to send all the packets.
 		 */
-		count += targs[i].count;
+		cur.pkts += targs[i].ctr.pkts;
+		cur.bytes += targs[i].ctr.bytes;
+		cur.events += targs[i].ctr.events;
+		/* collect the largest start (tic) and end (toc) times,
+		 * XXX maybe we should do the earliest tic, or do a weighted
+		 * average ?
+		 */
 		t_tic = timeval2spec(&tic);
 		t_toc = timeval2spec(&toc);
 		if (!timerisset(&tic) || timespec_ge(&targs[i].tic, &t_tic))
@@ -1563,29 +2325,26 @@
 	/* print output. */
 	timersub(&toc, &tic, &toc);
 	delta_t = toc.tv_sec + 1e-6* toc.tv_usec;
-	if (g->td_body == sender_body)
-		tx_output(count, g->pkt_size, delta_t);
+	if (g->td_type == TD_TYPE_SENDER)
+		tx_output(&cur, delta_t, "Sent");
 	else
-		rx_output(count, delta_t);
-
-	if (g->dev_type == DEV_NETMAP) {
-		munmap(g->nmd->mem, g->nmd->req.nr_memsize);
-		close(g->main_fd);
-	}
+		tx_output(&cur, delta_t, "Received");
 }
 
-
-struct sf {
+struct td_desc {
+	int ty;
 	char *key;
 	void *f;
 };
 
-static struct sf func[] = {
-	{ "tx",	sender_body },
-	{ "rx",	receiver_body },
-	{ "ping",	pinger_body },
-	{ "pong",	ponger_body },
-	{ NULL, NULL }
+static struct td_desc func[] = {
+	{ TD_TYPE_SENDER,	"tx",		sender_body },
+	{ TD_TYPE_RECEIVER,	"rx",		receiver_body },
+	{ TD_TYPE_OTHER,	"ping",		pinger_body },
+	{ TD_TYPE_OTHER,	"pong",		ponger_body },
+	{ TD_TYPE_SENDER,	"txseq",	txseq_body },
+	{ TD_TYPE_RECEIVER,	"rxseq",	rxseq_body },
+	{ 0,			NULL,	NULL }
 };
 
 static int
@@ -1654,6 +2413,8 @@
 main(int arc, char **argv)
 {
 	int i;
+	struct sigaction sa;
+	sigset_t ss;
 
 	struct glob_arg g;
 
@@ -1665,9 +2426,11 @@
 
 	g.main_fd = -1;
 	g.td_body = receiver_body;
+	g.td_type = TD_TYPE_RECEIVER;
 	g.report_interval = 1000;	/* report interval */
 	g.affinity = -1;
 	/* ip addresses can also be a range x.x.x.x-x.x.x.y */
+	g.af = AF_INET;     /* default */
 	g.src_ip.name = "10.0.0.1";
 	g.dst_ip.name = "10.1.0.1";
 	g.dst_mac.name = "ff:ff:ff:ff:ff:ff";
@@ -1675,7 +2438,7 @@
 	g.pkt_size = 60;
 	g.burst = 512;		// default
 	g.nthreads = 1;
-	g.cpus = 1;
+	g.cpus = 1;		// default
 	g.forever = 1;
 	g.tx_rate = 0;
 	g.frags = 1;
@@ -1682,9 +2445,9 @@
 	g.nmr_config = "";
 	g.virt_header = 0;
 
-	while ( (ch = getopt(arc, argv,
-			"a:f:F:n:i:Il:d:s:D:S:b:c:o:p:T:w:WvR:XC:H:e:m:P:zZ")) != -1) {
-		struct sf *fn;
+	while ((ch = getopt(arc, argv, "46a:f:F:Nn:i:Il:d:s:D:S:b:c:o:p:"
+		"T:Uw:WvR:XC:e:E:m:rP:zZA")) != -1) {
+		struct td_desc *fn;
 
 		switch(ch) {
 		default:
@@ -1692,10 +2455,26 @@
 			usage();
 			break;
 
+		case '4':
+			g.af = AF_INET;
+			break;
+
+		case '6':
+			g.af = AF_INET6;
+			break;
+
 		case 'n':
-			g.npackets = atoi(optarg);
+			g.npackets = strtoull(optarg, NULL, 10);
 			break;
 
+		case 'N':
+			normalize = 0;
+			break;
+
+		case 'U':
+			g.softchecksum = 1;
+			break;
+
 		case 'F':
 			i = atoi(optarg);
 			if (i < 1 || i > 63) {
@@ -1710,10 +2489,12 @@
 				if (!strcmp(fn->key, optarg))
 					break;
 			}
-			if (fn->key)
+			if (fn->key) {
 				g.td_body = fn->f;
-			else
+				g.td_type = fn->ty;
+			} else {
 				D("unrecognised function %s", optarg);
+			}
 			break;
 
 		case 'o':	/* data generation options */
@@ -1785,6 +2566,7 @@
 		case 'b':	/* burst */
 			g.burst = atoi(optarg);
 			break;
+
 		case 'c':
 			g.cpus = atoi(optarg);
 			break;
@@ -1811,24 +2593,21 @@
 		case 'C':
 			g.nmr_config = strdup(optarg);
 			break;
-		case 'H':
-			g.virt_header = atoi(optarg);
-			break;
 		case 'e': /* extra bufs */
 			g.extra_bufs = atoi(optarg);
 			break;
-		case 'm':
-			if (strcmp(optarg, "tx") == 0) {
-				g.options |= OPT_MONITOR_TX;
-			} else if (strcmp(optarg, "rx") == 0) {
-				g.options |= OPT_MONITOR_RX;
-			} else {
-				D("unrecognized monitor mode %s", optarg);
-			}
+		case 'E':
+			g.extra_pipes = atoi(optarg);
 			break;
 		case 'P':
 			g.packet_file = strdup(optarg);
 			break;
+		case 'm':
+			/* ignored */
+			break;
+		case 'r':
+			g.options |= OPT_RUBBISH;
+			break;
 		case 'z':
 			g.options |= OPT_RANDOM_SRC;
 			break;
@@ -1835,6 +2614,9 @@
 		case 'Z':
 			g.options |= OPT_RANDOM_DST;
 			break;
+		case 'A':
+			g.options |= OPT_PPS_STATS;
+			break;
 		}
 	}
 
@@ -1843,11 +2625,12 @@
 		usage();
 	}
 
-	i = system_ncpus();
+	g.system_cpus = i = system_ncpus();
 	if (g.cpus < 0 || g.cpus > i) {
 		D("%d cpus is too high, have only %d cpus", g.cpus, i);
 		usage();
 	}
+D("running on %d cpus (have %d)", g.cpus, i);
 	if (g.cpus == 0)
 		g.cpus = i;
 
@@ -1866,23 +2649,12 @@
 		g.src_mac.name = mybuf;
 	}
 	/* extract address ranges */
-	extract_ip_range(&g.src_ip);
-	extract_ip_range(&g.dst_ip);
 	extract_mac_range(&g.src_mac);
 	extract_mac_range(&g.dst_mac);
 
-	if (g.src_ip.start != g.src_ip.end ||
-	    g.src_ip.port0 != g.src_ip.port1 ||
-	    g.dst_ip.start != g.dst_ip.end ||
-	    g.dst_ip.port0 != g.dst_ip.port1)
-		g.options |= OPT_COPY;
+	g.options |= extract_ip_range(&g.src_ip, g.af);
+	g.options |= extract_ip_range(&g.dst_ip, g.af);
 
-	if (g.virt_header != 0 && g.virt_header != VIRT_HDR_1
-			&& g.virt_header != VIRT_HDR_2) {
-		D("bad virtio-net-header length");
-		usage();
-	}
-
     if (g.dev_type == DEV_TAP) {
 	D("want to use tap %s", g.ifname);
 	g.main_fd = tap_alloc(g.ifname);
@@ -1914,6 +2686,9 @@
 	if (g.extra_bufs) {
 		base_nmd.nr_arg3 = g.extra_bufs;
 	}
+	if (g.extra_pipes) {
+	    base_nmd.nr_arg1 = g.extra_pipes;
+	}
 
 	/*
 	 * Open the netmap device using nm_open().
@@ -1927,13 +2702,28 @@
 		D("Unable to open %s: %s", g.ifname, strerror(errno));
 		goto out;
 	}
+
+	if (g.nthreads > 1) {
+		struct nm_desc saved_desc = *g.nmd;
+		saved_desc.self = &saved_desc;
+		saved_desc.mem = NULL;
+		nm_close(g.nmd);
+		saved_desc.req.nr_flags &= ~NR_REG_MASK;
+		saved_desc.req.nr_flags |= NR_REG_ONE_NIC;
+		saved_desc.req.nr_ringid = 0;
+		g.nmd = nm_open(g.ifname, &base_nmd, NM_OPEN_IFNAME, &saved_desc);
+		if (g.nmd == NULL) {
+			D("Unable to open %s: %s", g.ifname, strerror(errno));
+			goto out;
+		}
+	}
 	g.main_fd = g.nmd->fd;
 	D("mapped %dKB at %p", g.nmd->req.nr_memsize>>10, g.nmd->mem);
 
-	/* get num of queues in tx or rx */ 
-	if (g.td_body == sender_body)
+	/* get num of queues in tx or rx */
+	if (g.td_type == TD_TYPE_SENDER)
 		devqueues = g.nmd->req.nr_tx_rings;
-	else 
+	else
 		devqueues = g.nmd->req.nr_rx_rings;
 
 	/* validate provided nthreads. */
@@ -1951,13 +2741,13 @@
 		    req->nr_arg2);
 		for (i = 0; i <= req->nr_tx_rings; i++) {
 			struct netmap_ring *ring = NETMAP_TXRING(nifp, i);
-			D("   TX%d at 0x%lx slots %d", i,
-			    (char *)ring - (char *)nifp, ring->num_slots);
+			D("   TX%d at 0x%p slots %d", i,
+			    (void *)((char *)ring - (char *)nifp), ring->num_slots);
 		}
 		for (i = 0; i <= req->nr_rx_rings; i++) {
 			struct netmap_ring *ring = NETMAP_RXRING(nifp, i);
-			D("   RX%d at 0x%lx slots %d", i,
-			    (char *)ring - (char *)nifp, ring->num_slots);
+			D("   RX%d at 0x%p slots %d", i,
+			    (void *)((char *)ring - (char *)nifp), ring->num_slots);
 		}
 	}
 
@@ -1964,12 +2754,14 @@
 	/* Print some debug information. */
 	fprintf(stdout,
 		"%s %s: %d queues, %d threads and %d cpus.\n",
-		(g.td_body == sender_body) ? "Sending on" : "Receiving from",
+		(g.td_type == TD_TYPE_SENDER) ? "Sending on" :
+			((g.td_type == TD_TYPE_RECEIVER) ? "Receiving from" :
+			"Working on"),
 		g.ifname,
 		devqueues,
 		g.nthreads,
 		g.cpus);
-	if (g.td_body == sender_body) {
+	if (g.td_type == TD_TYPE_SENDER) {
 		fprintf(stdout, "%s -> %s (%s -> %s)\n",
 			g.src_ip.name, g.dst_ip.name,
 			g.src_mac.name, g.dst_mac.name);
@@ -1985,12 +2777,13 @@
 
 
 	if (g.options) {
-		D("--- SPECIAL OPTIONS:%s%s%s%s%s\n",
+		D("--- SPECIAL OPTIONS:%s%s%s%s%s%s\n",
 			g.options & OPT_PREFETCH ? " prefetch" : "",
 			g.options & OPT_ACCESS ? " access" : "",
 			g.options & OPT_MEMCPY ? " memcpy" : "",
 			g.options & OPT_INDIRECT ? " indirect" : "",
-			g.options & OPT_COPY ? " copy" : "");
+			g.options & OPT_COPY ? " copy" : "",
+			g.options & OPT_RUBBISH ? " rubbish " : "");
 	}
 
 	g.tx_period.tv_sec = g.tx_period.tv_nsec = 0;
@@ -2010,7 +2803,7 @@
 		g.tx_period.tv_sec = g.tx_period.tv_nsec / 1000000000;
 		g.tx_period.tv_nsec = g.tx_period.tv_nsec % 1000000000;
 	}
-	if (g.td_body == sender_body)
+	if (g.td_type == TD_TYPE_SENDER)
 	    D("Sending %d packets every  %ld.%09ld s",
 			g.burst, g.tx_period.tv_sec, g.tx_period.tv_nsec);
 	/* Wait for PHY reset. */
@@ -2020,10 +2813,24 @@
 
 	/* Install ^C handler. */
 	global_nthreads = g.nthreads;
-	signal(SIGINT, sigint_h);
+	sigemptyset(&ss);
+	sigaddset(&ss, SIGINT);
+	/* block SIGINT now, so that all created threads will inherit the mask */
+	if (pthread_sigmask(SIG_BLOCK, &ss, NULL) < 0) {
+		D("failed to block SIGINT: %s", strerror(errno));
+	}
+	start_threads(&g);
+	/* Install the handler and re-enable SIGINT for the main thread */
+	sa.sa_handler = sigint_h;
+	if (sigaction(SIGINT, &sa, NULL) < 0) {
+		D("failed to install ^C handler: %s", strerror(errno));
+	}
 
-	start_threads(&g);
+	if (pthread_sigmask(SIG_UNBLOCK, &ss, NULL) < 0) {
+		D("failed to re-enable SIGINT: %s", strerror(errno));
+	}
 	main_thread(&g);
+	free(targs);
 	return 0;
 }
 
