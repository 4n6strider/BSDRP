Index: tools/tools/netmap/pkt-gen.c
===================================================================
--- tools/tools/netmap/pkt-gen.c	(revision 304373)
+++ tools/tools/netmap/pkt-gen.c	(working copy)
@@ -169,11 +169,12 @@
 	int pkt_size;
 	int burst;
 	int forever;
-	int npackets;	/* total packets to send */
+	uint64_t npackets;	/* total packets to send */
 	int frags;	/* fragments per packet */
 	int nthreads;
 	int cpus;
 	int options;	/* testing */
+	int softchecksum;	/* Software UDP checksum calculation */
 #define OPT_PREFETCH	1
 #define OPT_ACCESS	2
 #define OPT_COPY	4
@@ -565,6 +566,7 @@
 {
 	uint32_t a;
 	uint16_t p;
+	struct ether_header *eh = &pkt->eh;
 	struct ip *ip = &pkt->ip;
 	struct udphdr *udp = &pkt->udp;
 
@@ -611,6 +613,25 @@
 	ip->ip_dst.s_addr = htonl(g->dst_ip.start);
     } while (0);
     // update checksum
+	/* Some NIC disable hardware CRC checksum in netmap mode
+	 * and don't allow to re-enable it */
+
+	if (g->softchecksum) {
+		ip->ip_sum = 0;
+		ip->ip_sum = wrapsum(checksum(ip, sizeof(*ip), 0));
+		/* UDP checksum */
+		uint16_t paylen = g->pkt_size - sizeof(*eh) - sizeof(struct ip);
+		udp->uh_sum = 0;
+		udp->uh_sum = wrapsum(checksum(udp, sizeof(*udp),
+			checksum(pkt->body,
+				paylen - sizeof(*udp),
+				checksum(&ip->ip_src, 2 * sizeof(ip->ip_src),
+					IPPROTO_UDP + (u_int32_t)ntohs(udp->uh_ulen)
+				)
+			)
+		));
+	}
+
 }
 
 /*
@@ -810,10 +831,10 @@
 	struct targ *targ = (struct targ *) data;
 	struct pollfd pfd = { .fd = targ->fd, .events = POLLIN };
 	struct netmap_if *nifp = targ->nmd->nifp;
-	int i, rx = 0, n = targ->g->npackets;
+	int i, rx = 0;
 	void *frame;
 	int size;
-	uint32_t sent = 0;
+	uint64_t sent = 0, n = targ->g->npackets;
 	struct timespec ts, now, last_print;
 	uint32_t count = 0, min = 1000000000, av = 0;
 
@@ -828,7 +849,7 @@
 
 	clock_gettime(CLOCK_REALTIME_PRECISE, &last_print);
 	now = last_print;
-	while (n == 0 || (int)sent < n) {
+	while (n == 0 || sent < n) {
 		struct netmap_ring *ring = NETMAP_TXRING(nifp, 0);
 		struct netmap_slot *slot;
 		char *p;
@@ -878,7 +899,7 @@
 					ts.tv_nsec += 1000000000;
 					ts.tv_sec--;
 				}
-				if (1) D("seq %d/%d delta %d.%09d", seq, sent,
+				if (1) D("seq %d/%lu delta %d.%09d", seq, sent,
 					(int)ts.tv_sec, (int)ts.tv_nsec);
 				if (ts.tv_nsec < (int)min)
 					min = ts.tv_nsec;
@@ -919,13 +940,14 @@
 	struct pollfd pfd = { .fd = targ->fd, .events = POLLIN };
 	struct netmap_if *nifp = targ->nmd->nifp;
 	struct netmap_ring *txring, *rxring;
-	int i, rx = 0, sent = 0, n = targ->g->npackets;
+	int i, rx = 0;
+	uint64_t sent = 0, n = targ->g->npackets;
 
 	if (targ->g->nthreads > 1) {
 		D("can only reply ping with 1 thread");
 		return NULL;
 	}
-	D("understood ponger %d but don't know how to do it", n);
+	D("understood ponger %lu but don't know how to do it", n);
 	while (n == 0 || sent < n) {
 		uint32_t txcur, txavail;
 //#define BUSYWAIT
@@ -1066,8 +1088,9 @@
 	struct pollfd pfd = { .fd = targ->fd, .events = POLLOUT };
 	struct netmap_if *nifp;
 	struct netmap_ring *txring;
-	int i, n = targ->g->npackets / targ->g->nthreads;
-	int64_t sent = 0;
+	int i;
+	uint64_t n = targ->g->npackets / targ->g->nthreads;
+	uint64_t sent = 0;
 	int options = targ->g->options | OPT_COPY;
 	struct timespec nexttime = { 0, 0}; // XXX silence compiler
 	int rate_limit = targ->g->tx_rate;
@@ -1157,7 +1180,8 @@
 			options &= ~OPT_COPY;
 		}
 		for (i = targ->nmd->first_tx_ring; i <= targ->nmd->last_tx_ring; i++) {
-			int m, limit = rate_limit ?  tosend : targ->g->burst;
+			int m;
+			uint64_t limit = rate_limit ?  tosend : targ->g->burst;
 			if (n > 0 && n - sent < limit)
 				limit = n - sent;
 			txring = NETMAP_TXRING(nifp, i);
@@ -1409,6 +1433,7 @@
 		"\t-X			dump payload\n"
 		"\t-H len		add empty virtio-net-header with size 'len'\n"
 	        "\t-P file		load packet from pcap file\n"
+		"\t-U			enable software UDP CRC chekcsum\n"
 		"\t-z			use random IPv4 src address/port\n"
 		"\t-Z			use random IPv4 dst address/port\n"
 		"",
@@ -1683,7 +1708,7 @@
 	g.virt_header = 0;
 
 	while ( (ch = getopt(arc, argv,
-			"a:f:F:n:i:Il:d:s:D:S:b:c:o:p:T:w:WvR:XC:H:e:m:P:zZ")) != -1) {
+			"a:f:F:n:i:Il:d:s:D:S:b:c:o:p:T:Uw:WvR:XC:H:e:m:P:zZ")) != -1) {
 		struct sf *fn;
 
 		switch(ch) {
@@ -1693,7 +1718,7 @@
 			break;
 
 		case 'n':
-			g.npackets = atoi(optarg);
+			g.npackets = strtoull(optarg, NULL, 10);
 			break;
 
 		case 'F':
@@ -1785,6 +1810,9 @@
 		case 'b':	/* burst */
 			g.burst = atoi(optarg);
 			break;
+		case 'U':	/* software UDP checksum */
+			g.softchecksum = 1;
+			break;
 		case 'c':
 			g.cpus = atoi(optarg);
 			break;
